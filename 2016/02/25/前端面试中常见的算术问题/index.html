<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>前端面试中常见的算术问题 | 高乐高</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端面试中的常见的算法问题虽说我们很多时候前端很少有机会接触到算法。大多都交互性的操作，然而从各大公司面试来看，算法依旧是考察的一方面。实际上学习数据结构与算法对于工程师去理解和分析问题都是有帮助的。如果将来当我们面对较为复杂的问题，这些基础知识的积累可以帮助我们更好的优化解决思路。下面罗列在前端面试中经常撞见的几个问题吧
Q1 判断一个单词是否是回文？回文是指把相同的词汇或句子，在下文中调换位置">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试中常见的算术问题">
<meta property="og:url" content="http://yoursite.com/2016/02/25/前端面试中常见的算术问题/index.html">
<meta property="og:site_name" content="高乐高">
<meta property="og:description" content="前端面试中的常见的算法问题虽说我们很多时候前端很少有机会接触到算法。大多都交互性的操作，然而从各大公司面试来看，算法依旧是考察的一方面。实际上学习数据结构与算法对于工程师去理解和分析问题都是有帮助的。如果将来当我们面对较为复杂的问题，这些基础知识的积累可以帮助我们更好的优化解决思路。下面罗列在前端面试中经常撞见的几个问题吧
Q1 判断一个单词是否是回文？回文是指把相同的词汇或句子，在下文中调换位置">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif">
<meta property="og:image" content="http://img1.vued.vanthink.cn/vued90edf7b944ec479ee8b4203cf56e158d.png">
<meta property="og:image" content="http://img1.vued.vanthink.cn/vued95685e8f89199babd6273a93651ecd8b.png">
<meta property="og:updated_time" content="2016-11-25T13:44:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试中常见的算术问题">
<meta name="twitter:description" content="前端面试中的常见的算法问题虽说我们很多时候前端很少有机会接触到算法。大多都交互性的操作，然而从各大公司面试来看，算法依旧是考察的一方面。实际上学习数据结构与算法对于工程师去理解和分析问题都是有帮助的。如果将来当我们面对较为复杂的问题，这些基础知识的积累可以帮助我们更好的优化解决思路。下面罗列在前端面试中经常撞见的几个问题吧
Q1 判断一个单词是否是回文？回文是指把相同的词汇或句子，在下文中调换位置">
<meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif">
  
    <link rel="alternative" href="/atom.xml" title="高乐高" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars2.githubusercontent.com/u/20942807?v=3&amp;u=29f58348a0cff3578d3647fba8fb54bc86186c1e&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">特仑苏</a></h1>
		</hgroup>

		
		<p class="header-subtitle">只有努力才能得到自己想要的东西</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/wzj1996/wzj1996.github.io.git" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/3137128535" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">特仑苏</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars2.githubusercontent.com/u/20942807?v=3&amp;u=29f58348a0cff3578d3647fba8fb54bc86186c1e&amp;s=140" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">特仑苏</h1>
			</hgroup>
			
			<p class="header-subtitle">只有努力才能得到自己想要的东西</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wzj1996/wzj1996.github.io.git" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3137128535" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-前端面试中常见的算术问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      前端面试中常见的算术问题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前端面试中的常见的算法问题"><a href="#前端面试中的常见的算法问题" class="headerlink" title="前端面试中的常见的算法问题"></a>前端面试中的常见的算法问题</h2><pre><code>虽说我们很多时候前端很少有机会接触到算法。大多都交互性的操作，然而从各大公司面试来看，算法依旧是考察的一方面。实际上学习数据结构与算法对于工程师去理解和分析问题都是有帮助的。如果将来当我们面对较为复杂的问题，这些基础知识的积累可以帮助我们更好的优化解决思路。下面罗列在前端面试中经常撞见的几个问题吧
</code></pre><h3 id="Q1-判断一个单词是否是回文？"><a href="#Q1-判断一个单词是否是回文？" class="headerlink" title="Q1 判断一个单词是否是回文？"></a>Q1 判断一个单词是否是回文？</h3><pre><code>回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider .
</code></pre><p>很多人拿到这样的题目非常容易想到用for 将字符串颠倒字母顺序然后匹配就行了。其实重要的考察的就是对于reverse的实现。其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。</p>
<pre><code>function checkPalindrom(str) {  
return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;);
}    
</code></pre><h3 id="Q2-去掉一组整型数组重复的值"><a href="#Q2-去掉一组整型数组重复的值" class="headerlink" title="Q2 去掉一组整型数组重复的值"></a>Q2 去掉一组整型数组重复的值</h3><pre><code>比如输入: [1,13,24,11,11,14,1,2] 
输出: [1,13,24,11,14,2]
需要去掉重复的11 和 1 这两个元素。
</code></pre><p>这道问题出现在诸多的前端面试题中，主要考察个人对Object的使用，利用key来进行筛选。</p>
<pre><code>/**
* unique an array 
**/
let unique = function(arr) {  
let hashTable = {};
let data = [];
for(let i=0,l=arr.length;i&lt;l;i++) {
if(!hashTable[arr[i]]) {
  hashTable[arr[i]] = true;
  data.push(arr[i]);
}
}
return data
}
module.exports = unique;  
</code></pre><h3 id="Q3-统计一个字符串出现最多的字母"><a href="#Q3-统计一个字符串出现最多的字母" class="headerlink" title="Q3 统计一个字符串出现最多的字母"></a>Q3 统计一个字符串出现最多的字母</h3><p>给出一段英文连续的英文字符窜，找出重复出现次数最多的字母</p>
<pre><code>输入 ： afjghdfraaaasdenas 
输出 ： a
</code></pre><p>前面出现过去重的算法，这里需要是统计重复次数。</p>
<pre><code>function findMaxDuplicateChar(str) {  
if(str.length == 1) {
return str;
}
let charObj = {};
for(let i=0;i&lt;str.length;i++) {
if(!charObj[str.charAt(i)]) {
  charObj[str.charAt(i)] = 1;
}else{
  charObj[str.charAt(i)] += 1;
}
}
let maxChar = &apos;&apos;,
  maxValue = 1;
  for(var k in charObj) {
if(charObj[k] &gt;= maxValue) {
  maxChar = k;
  maxValue = charObj[k];
}
}
return maxChar;
}
module.exports = findMaxDuplicateChar;
</code></pre><h3 id="Q4-排序算法"><a href="#Q4-排序算法" class="headerlink" title="Q4 排序算法"></a>Q4 排序算法</h3><p>如果抽到算法题目的话，应该大多都是比较开放的题目，不限定算法的实现，但是一定要求掌握其中的几种，所以冒泡排序，这种较为基础并且便于理解记忆的算法一定需要熟记于心。冒泡排序算法就是依次比较大小，小的的大的进行位置上的交换。</p>
<pre><code>function bubbleSort(arr) {  
for(let i = 0,l=arr.length;i&lt;l-1;i++) {
    for(let j = i+1;j&lt;l;j++) { 
      if(arr[i]&gt;arr[j]) {
            let tem = arr[i];
            arr[i] = arr[j];
            arr[j] = tem;
        }
    }
}
return arr;
}
module.exports = bubbleSort;
</code></pre><p>除了冒泡排序外，其实还有很多诸如 插入排序,快速排序，希尔排序等。每一种排序算法都有各自的特点。全部掌握也不需要，但是心底一定要熟悉几种算法。 比如快速排序，其效率很高，而其基本原理如图(来自wiki)：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="Mou"></p>
<p>算法参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组了</p>
<pre><code>function quickSort(arr) {

if(arr.length&lt;=1) {
    return arr;
}

let leftArr = [];
let rightArr = [];
let q = arr[0];
for(let i = 1,l=arr.length; i&lt;l; i++) {
    if(arr[i]&gt;q) {
        rightArr.push(arr[i]);
    }else{
        leftArr.push(arr[i]);
    }
}

return [].concat(quickSort(leftArr),[q],quickSort(rightArr));
}
module.exports = quickSort;
</code></pre><p>安利大家一个学习的地址，通过动画演示算法的实现。</p>
<p><a href=" ">HTML5 Canvas Demo: Sorting Algorithms</a></p>
<h3 id="Q5-不借助临时变量，进行两个整数的交换"><a href="#Q5-不借助临时变量，进行两个整数的交换" class="headerlink" title="Q5 不借助临时变量，进行两个整数的交换"></a>Q5 不借助临时变量，进行两个整数的交换</h3><pre><code>输入 a = 2, b = 4 输出 a = 4, b =2
</code></pre><p>这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b进行置换。</p>
<p>主要是利用 + - 去进行运算，类似 a = a + ( b - a) 实际上等同于最后 的 a = b;</p>
<pre><code>function swap(a , b) {  
b = b - a;
a = a + b;
b = a - b;
return [a,b];
}
module.exports = swap;    
</code></pre><h3 id="Q6-使用canvas-绘制一个有限度的斐波那契数列的曲线"><a href="#Q6-使用canvas-绘制一个有限度的斐波那契数列的曲线" class="headerlink" title="Q6 使用canvas 绘制一个有限度的斐波那契数列的曲线"></a>Q6 使用canvas 绘制一个有限度的斐波那契数列的曲线</h3><p><img src="http://img1.vued.vanthink.cn/vued90edf7b944ec479ee8b4203cf56e158d.png" alt="Mou"></p>
<p>数列长度限定在9.</p>
<p>斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。我们一般都知道定义</p>
<pre><code>fibo[i] = fibo[i-1]+fibo[i-2];  
</code></pre><p>生成斐波那契数组的方法</p>
<pre><code>function getFibonacci(n) {  
var fibarr = [];
var i = 0;
while(i&lt;n) {
if(i&lt;=1) {
  fibarr.push(i);
}else{
  fibarr.push(fibarr[i-1] + fibarr[i-2])
}
i++;
}
return fibarr;
}
</code></pre><p>剩余的工作就是利用canvas arc方法进行曲线绘制了</p>
<h3 id="Q7-找出下列正数组的最大差值比如"><a href="#Q7-找出下列正数组的最大差值比如" class="headerlink" title="Q7 找出下列正数组的最大差值比如:"></a>Q7 找出下列正数组的最大差值比如:</h3><pre><code>输入 [10,5,11,7,8,9]
输出 6
</code></pre><p>这是通过一道题目去测试对于基本的数组的最大值的查找，很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。</p>
<pre><code>function getMaxProfit(arr) {
var minPrice = arr[0];
var maxProfit = 0;

for (var i = 0; i &lt; arr.length; i++) {
    var currentPrice = arr[i];

    minPrice = Math.min(minPrice, currentPrice);

    var potentialProfit = currentPrice - minPrice;

    maxProfit = Math.max(maxProfit, potentialProfit);
}

return maxProfit;
}    
</code></pre><h3 id="Q8-随机生成指定长度的字符串"><a href="#Q8-随机生成指定长度的字符串" class="headerlink" title="Q8 随机生成指定长度的字符串"></a>Q8 随机生成指定长度的字符串</h3><p>实现一个算法，随机生成指制定长度的字符窜。</p>
<pre><code>比如给定 长度 8  输出 4ldkfg9j


function randomString(n) {  
let str = &apos;abcdefghijklmnopqrstuvwxyz9876543210&apos;;
let tmp = &apos;&apos;,
  i = 0,
  l = str.length;
  for (i = 0; i &lt; n; i++) {
tmp += str.charAt(Math.floor(Math.random() * l));
}
return tmp;
}
module.exports = randomString;
</code></pre><h3 id="Q9-实现类似getElementsByClassName-的功能"><a href="#Q9-实现类似getElementsByClassName-的功能" class="headerlink" title="Q9 实现类似getElementsByClassName 的功能"></a>Q9 实现类似getElementsByClassName 的功能</h3><p>自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供DOM查找函数。</p>
<pre><code>function queryClassName(node, name) {  
var starts = &apos;(^|[ \n\r\t\f])&apos;,
   ends = &apos;([ \n\r\t\f]|$)&apos;;
   var array = [],
    regex = new RegExp(starts + name + ends),
    elements = node.getElementsByTagName(&quot;*&quot;),
    length = elements.length,
    i = 0,
    element;

while (i &lt; length) {
    element = elements[i];
    if (regex.test(element.className)) {
        array.push(element);
    }

    i += 1;
}

return array;
}
</code></pre><h3 id="Q10-使用JS-实现二叉查找树-Binary-Search-Tree"><a href="#Q10-使用JS-实现二叉查找树-Binary-Search-Tree" class="headerlink" title="Q10 使用JS 实现二叉查找树(Binary Search Tree)"></a>Q10 使用JS 实现二叉查找树(Binary Search Tree)</h3><p>一般叫全部写完的概率比较少，但是重点考察你对它的理解和一些基本特点的实现。 二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树：</p>
<pre><code>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

任意节点的左、右子树也分别为二叉查找树；

没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。
</code></pre><p><img src="http://img1.vued.vanthink.cn/vued95685e8f89199babd6273a93651ecd8b.png" alt="Mou">    </p>
<p>在写的时候需要足够理解二叉搜素树的特点，需要先设定好每个节点的数据结构</p>
<pre><code>class Node {  
constructor(data, left, right) {
this.data = data;
this.left = left;
this.right = right;
}
}
</code></pre><p>树是有节点构成，由根节点逐渐延生到各个子节点，因此它具备基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法.</p>
<pre><code>    class BinarySearchTree {
    constructor() {
this.root = null;
}
insert(data) {
let n = new Node(data, null, null);
if (!this.root) {
  return this.root = n;
}
let currentNode = this.root;
let parent = null;
while (1) {
  parent = currentNode;
  if (data &lt; currentNode.data) {
    currentNode = currentNode.left;
    if (currentNode === null) {
      parent.left = n;
      break;
    }
  } else {
    currentNode = currentNode.right;
    if (currentNode === null) {
      parent.right = n;
      break;
    }
  }
}
}

remove(data) {
this.root = this.removeNode(this.root, data)
}

removeNode(node, data) {
if (node == null) {
  return null;
}

if (data == node.data) {
  // no children node
  if (node.left == null &amp;&amp; node.right == null) {
    return null;
  }
  if (node.left == null) {
    return node.right;
  }
  if (node.right == null) {
    return node.left;
  }

  let getSmallest = function(node) {
    if(node.left === null &amp;&amp; node.right == null) {
      return node;
    }
    if(node.left != null) {
      return node.left;
    }
    if(node.right !== null) {
      return getSmallest(node.right);
    }

  }
  let temNode = getSmallest(node.right);
  node.data = temNode.data;
  node.right = this.removeNode(temNode.right,temNode.data);
  return node;

} else if (data &lt; node.data) {
  node.left = this.removeNode(node.left,data);
  return node;
} else {
  node.right = this.removeNode(node.right,data);
  return node;
}
}

find(data) {
var current = this.root;
while (current != null) {
  if (data == current.data) {
    break;
  }
  if (data &lt; current.data) {
    current = current.left;
  } else {
    current = current.right
  }
}
return current.data;
}
}
module.exports = BinarySearchTree;    
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/02/25/前端面试中常见的算术问题/" class="archive-article-date">
  	<time datetime="2016-02-25T13:25:39.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-02-25</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2016/01/21/正则/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">正则</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>







<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-前端面试中常见的算术问题" data-title="前端面试中常见的算术问题" data-url="http://yoursite.com/2016/02/25/前端面试中常见的算术问题/"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 特仑苏
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>