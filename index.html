<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>高乐高</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="高乐高">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="高乐高">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高乐高">
  
    <link rel="alternative" href="/atom.xml" title="高乐高" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars2.githubusercontent.com/u/20942807?v=3&amp;u=29f58348a0cff3578d3647fba8fb54bc86186c1e&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">特仑苏</a></h1>
		</hgroup>

		
		<p class="header-subtitle">只有努力才能得到自己想要的东西</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/wzj1996/wzj1996.github.io.git" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/3137128535" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">特仑苏</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars2.githubusercontent.com/u/20942807?v=3&amp;u=29f58348a0cff3578d3647fba8fb54bc86186c1e&amp;s=140" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">特仑苏</h1>
			</hgroup>
			
			<p class="header-subtitle">只有努力才能得到自己想要的东西</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wzj1996/wzj1996.github.io.git" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3137128535" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-vue-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/06/vue-js/">vue.js</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Vue-js双向绑定的实现原理"><a href="#Vue-js双向绑定的实现原理" class="headerlink" title="Vue.js双向绑定的实现原理"></a>Vue.js双向绑定的实现原理</h2><hr>
<p> Vue.js最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。本文仅探究几乎所有Vue的开篇介绍都会提到的hello world双向绑定是怎样实现的。先讲涉及的知识点，再参考源码，用尽可能少的代码实现那个hello world开篇示例</p>
<h3 id="一、访问器属性"><a href="#一、访问器属性" class="headerlink" title="一、访问器属性"></a>一、访问器属性</h3><hr>
<p>访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过defineProperty()方法单独定义。</p>
<pre><code>var obj = { };

   // 为obj定义一个名为hello的访问器属性

   Object.defineProperty(obj, &quot;hello&quot;, {

     get: function () {return sth},

     set: function (val) {/* do sth */}

   })

   obj.hello // 可以像普通属性一样读取访问器属性

   访问器属性的&quot;值&quot;比较特殊，读取或设置访问器属性的值，实际上是调用其内部特性：get和set函数。

   obj.hello // 读取属性，就是调用get函数并返回get函数的返回值
   obj.hello = &quot;abc&quot; // 为属性赋值，就是调用set函数，赋值其实是传参
</code></pre><p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120155820248-500778578.png" alt="Mou"> </p>
<pre><code>get和set方法内部的this都指向obj，这意味着get和set函数可以操作对象内部的值。另外，访问器属性的会&quot;覆盖&quot;同名的普通属性，因为访问器属性会被优先访问，与其同名的普通属性则会被忽略（也就是所谓的被&quot;劫持&quot;了）。
</code></pre><h3 id="二、极简双向绑定的实现"><a href="#二、极简双向绑定的实现" class="headerlink" title="二、极简双向绑定的实现"></a>二、极简双向绑定的实现</h3><hr>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120155856263-1051312268.png" alt="Mou"></p>
<p>此例实现的效果是：随文本框输入文字的变化，span中会同步显示相同的文字内容；在js或控制台显式的修改obj.name的值，视图会相应更新。这样就实现了model =&gt;view以及view =&gt; model的双向绑定，并且是响应式的。</p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160007029-1444374091.png" alt="Mou"></p>
<pre><code>以上就是Vue实现双向绑定的基本原理。
</code></pre><h3 id="三、分解任务"><a href="#三、分解任务" class="headerlink" title="三、分解任务"></a>三、分解任务</h3><hr>
<p>上述示例仅仅是为了说明原理。我们最终要实现的是：</p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160023154-705049955.png" alt="Mou"></p>
<p>首先将该任务分成几个子任务：</p>
<pre><code>1、输入框以及文本节点与data中的数据绑定

2、输入框内容变化时，data中的数据同步变化。即view =&gt; model的变化。

3、data中的数据变化时，文本节点的内容同步变化。即model =&gt; view的变化。

要实现任务一，需要对DOM进行编译，这里有一个知识点：            DocumentFragment。
</code></pre><h3 id="四、DocumentFragment"><a href="#四、DocumentFragment" class="headerlink" title="四、DocumentFragment"></a>四、DocumentFragment</h3><hr>
<p>DocumentFragment（文档片段）可以看作节点容器，它可以包含多个子节点，当我们将它插入到DOM中时，只有它的子节点会插入目标节点，所以把它看作一组节点的容器。使用DocumentFragment处理节点，速度和性能远远优于直接操作DOM。Vue进行编译时，就是将挂载目标的所有子节点劫持（真的是劫持）到DocumentFragment中，经过一番处理后，再将DocumentFragment整体返回插入挂载目标。    </p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160124217-527060528.png" alt="Mou"><br><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160134232-1887803443.png" alt="Mou"></p>
<h3 id="五、数据初始化绑定"><a href="#五、数据初始化绑定" class="headerlink" title="五、数据初始化绑定"></a>五、数据初始化绑定</h3><hr>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160200217-164611845.png" alt="Mou"></p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160233873-127171744.png" alt="Mou"></p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160243545-44236467.png" alt="Mou"></p>
<pre><code>以上代码实现了任务一，我们可以看到，hello world已经呈现在输入框和文本节点中。
</code></pre><p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160327467-1883154446.png" alt="Mou"></p>
<h3 id="六、响应式的数据绑定"><a href="#六、响应式的数据绑定" class="headerlink" title="六、响应式的数据绑定"></a>六、响应式的数据绑定</h3><hr>
<p>再来看任务二的实现思路：当我们在输入框输入数据的时候，首先触发input事件（或者keyup、change事件），在相应的事件处理程序中，我们获取输入框的value并赋值给vm实例的text属性。我们会利用defineProperty将data中的text劫持为vm的访问器属性，因此给vm.text赋值，就会触发set方法。在set方法中主要做两件事，第一是更新属性的值，第二留到任务三再说。</p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160409513-886321336.png" alt="Mou"></p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160441326-1073521186.png" alt="Mou"></p>
<pre><code>任务二也就完成了，text属性值会与输入框的内容同步变化：
</code></pre><p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160501763-1127106704.png" alt="Mou">    </p>
<h3 id="七、订阅-发布模式（subscribe-amp-publish）"><a href="#七、订阅-发布模式（subscribe-amp-publish）" class="headerlink" title="七、订阅/发布模式（subscribe&amp;publish）"></a>七、订阅/发布模式（subscribe&amp;publish）</h3><hr>
<p> text属性变化了，set方法触发了，但是文本节点的内容没有变化。如何让同样绑定到text的文本节点也同步变化呢？这里又有一个知识点：订阅发布模式。</p>
<p> 订阅发布模式（又称观察者模式）定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象。</p>
<p> 发布者发出通知 =&gt; 主题对象收到通知并推送给订阅者 =&gt; 订阅者执行相应操作</p>
<p> <img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160541513-1856723431.png" alt="Mou"></p>
<pre><code>之前提到的，当set方法触发后做的第二件事就是作为发布者发出通知：“我是属性text，我变了”。文本节点则是作为订阅者，在收到消息后执行相应的更新操作。 
</code></pre><h3 id="八、双向绑定的实现"><a href="#八、双向绑定的实现" class="headerlink" title="八、双向绑定的实现"></a>八、双向绑定的实现</h3><hr>
<p>   回顾一下，每当new一个Vue，主要做了两件事：第一个是监听数据：observe(data)，第二个是编译HTML：nodeToFragement(id)。<br>   在监听数据的过程中，会为data中的每一个属性生成一个主题对象dep。<br>    在编译HTML的过程中，会为每个与数据绑定相关的节点生成一个订阅者watcher，watcher会将自己添加到相应属性的dep中。<br>    我们已经实现：修改输入框内容 =&gt; 在事件回调函数中修改属性值 =&gt; 触发属性的set方法。<br>    接下来我们要实现的是：发出通知dep.notify() =&gt; 触发订阅者的update方法 =&gt; 更新视图。<br>    这里的关键逻辑是：如何将watcher添加到关联属性的dep中。</p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160644154-1888733590.png" alt="Mou"></p>
<pre><code>在编译HTML过程中，为每个与data关联的节点生成一个Watcher。Watcher函数中发生了什么呢?
</code></pre><p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160659310-1972832043.png" alt="Mou"></p>
<p>首先，将自己赋给了一个全局变量Dep.target；</p>
<p>其次，执行了update方法，进而执行了get方法，get的方法读取了vm的访问器属性，从而触发了访问器属性的get方法，get方法中将该watcher添加到了对应访问器属性的dep中；</p>
<p>再次，获取属性的值，然后更新视图。</p>
<p>最后，将Dep.target设为空。因为它是全局变量，也是watcher与dep关联的唯一桥梁，任何时刻都必须保证Dep.target只有一个值。</p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160749388-947918217.png" alt="Mou"></p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160726592-168522955.png" alt="Mou"></p>
<p><img src="http://images2015.cnblogs.com/blog/925891/201611/925891-20161120160814420-1825354650.png" alt="Mou"></p>
<pre><code>至此，hello world双向绑定就基本实现了。文本内容会随输入框内容同步变化，在控制器中修改vm.text的值，会同步反映到文本内容中。    
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/03/06/vue-js/" class="archive-article-date">
  	<time datetime="2016-03-06T10:02:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-03-06</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-vue-js" data-title="vue.js" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-Flex布局教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/05/Flex布局教程/">Flex布局教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h3><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为Flex布局。</p>
<pre><code>.box{
display: flex;
}
</code></pre><p>行内元素也可以使用Flex布局。</p>
<pre><code>.box{
display: inline-flex;
}
</code></pre><p>Webkit内核的浏览器，必须加上-webkit前缀。</p>
<pre><code>.box{
display: -webkit-flex; /* Safari */
display: flex;
}
</code></pre><p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p>
<h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><hr>
<p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="mou"></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h3 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h3><hr>
<p>以下6个属性设置在容器上。</p>
<pre><code>·flex-direction
·flex-wrap
·flex-flow
·justify-content
·align-items
·align-content
</code></pre><p>3.1 flex-direction属性    </p>
<hr>
<p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p>
<pre><code>.box {
flex-direction: row | row-reverse | column | column-reverse;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="Mou"></p>
<p>它可能有4个值。</p>
<pre><code>·row（默认值）：主轴为水平方向，起点在左端。
·row-reverse：主轴为水平方向，起点在右端。
·column：主轴为垂直方向，起点在上沿。
·column-reverse：主轴为垂直方向，起点在下沿。
</code></pre><p>3.2 flex-wrap属性</p>
<hr>
<p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="Mou"></p>
<pre><code>.box{
flex-wrap: nowrap | wrap | wrap-reverse;
}
</code></pre><p>它可能取三个值。</p>
<p>（1）nowrap（默认）：不换行。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="Mou"></p>
<p>（2）wrap：换行，第一行在上方。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="Mou"></p>
<p>（3）wrap-reverse：换行，第一行在下方。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="Mou"></p>
<p>3.3 flex-flow</p>
<hr>
<p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
<pre><code>.box {
flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;
}
</code></pre><p>3.4 justify-content属性</p>
<hr>
<p>justify-content属性定义了项目在主轴上的对齐方式。</p>
<pre><code>.box {
justify-content: flex-start | flex-end | center | space-between | space-around;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="Mou"></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<pre><code>·flex-start（默认值）：左对齐
·flex-end：右对齐
·center： 居中
·space-between：两端对齐，项目之间的间隔都相等。
·space-around：每个项目两侧的间隔相等。所以，项目之间的间隔    ·比项目与边框的间隔大一倍。
</code></pre><p>3.5 align-items属性</p>
<hr>
<p>align-items属性定义项目在交叉轴上如何对齐。</p>
<pre><code>.box {
align-items: flex-start | flex-end | center | baseline | stretch;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="Mou"></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<pre><code>·flex-start：交叉轴的起点对齐。
·flex-end：交叉轴的终点对齐。
·center：交叉轴的中点对齐。
·baseline: 项目的第一行文字的基线对齐。
·stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
</code></pre><p>3.6 align-content属性</p>
<hr>
<p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<pre><code>.box {
 align-content: flex-start | flex-end | center | space-between | space-around | stretch;
 }
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="Mou"></p>
<p>该属性可能取6个值。</p>
<pre><code>flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴。
</code></pre><h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><hr>
<p>以下6个属性设置在项目上。</p>
<pre><code>order
flex-grow
flex-shrink
flex-basis
flex
align-self
</code></pre><p>4.1 order属性</p>
<hr>
<p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<pre><code>.item {
order: &lt;integer&gt;;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="Mou">    </p>
<p>4.2 flex-grow属性</p>
<hr>
<p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<pre><code>.item {
flex-grow: &lt;number&gt;; /* default 0 */
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="Mou"></p>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<p>4.3 flex-shrink属性</p>
<hr>
<p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<pre><code>.item {
flex-shrink: &lt;number&gt;; /* default 1 */
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="Mou"></p>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<p>4.4 flex-basis属性</p>
<hr>
<p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
<pre><code>.item {
flex-basis: &lt;length&gt; | auto; /* default auto */
}
</code></pre><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
<p>4.5 flex属性</p>
<hr>
<p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
<pre><code>.item {
 flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]
 }
</code></pre><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>4.6 align-self属性</p>
<hr>
<p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<pre><code>.item {align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="Mou"></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。     </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/03/05/Flex布局教程/" class="archive-article-date">
  	<time datetime="2016-03-05T01:54:30.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-03-05</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-Flex布局教程" data-title="Flex布局教程" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-PHP连接sql" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/02/PHP连接sql/">PHP连接sql</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="PHP连接数据库"><a href="#PHP连接数据库" class="headerlink" title="PHP连接数据库"></a>PHP连接数据库</h3><p>连接数据库有俩种方式</p>
<p>1、面向过程:</p>
<pre><code>$link = mysqli_connect(&quot;localhost(本地地址)&quot;,&quot;数据库的账户&quot;,&quot;&quot;,&quot;数据库的名字&quot;);
if(mysqli_errno($link)){
echo mysqli_error($link);
}
//sql语句
$sql = &quot;INSERT INTO users (username,age,pwd) VALUES (&apos;王五&apos;,20,654321)&quot;;
//设置编码格式
//方式一：
//mysqli_query($link,&quot;set names utf8&quot;);
//方式二
mysqli_set_charset($link, &quot;utf8&quot;);
//执行sql
$res = mysqli_query($link, $sql);
if($res){
echo &quot;添加成功&quot;;
}else{
echo &quot;添加失败&quot;;
}
</code></pre><p>2、面向对象</p>
<pre><code>$mysqli = new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;house&quot;);
if($mysqli-&gt;errno){
echo $mysqli-&gt;error;
}else{
echo &quot;连接数据库成功&quot;;
}
$name = &quot;马云&quot;;
$age  = 38;
$pwd = 123654;
$sql = &quot;INSERT INTO users (username,age,pwd) VALUES (&apos;&quot;.$name.&quot;&apos;,$age,$pwd)&quot;;
//echo $sql;die;
$reslut = add($sql);
if($reslut){
echo &quot;添加成功&quot;;
}else{
echo &quot;添加失败&quot;;
}
</code></pre><h3 id="数据库的增删改查"><a href="#数据库的增删改查" class="headerlink" title="数据库的增删改查"></a>数据库的增删改查</h3><p>下面都是我封装的函数…</p>
<p>1、添加<br>sql语句<br>举例:<br>$sql = “INSERT INTO users(username,pwd,age) VALUES (‘王林’,123123,45)”;</p>
<p>users在你数据库表的名字 username,pwd,age,在你数据库的字段,VALEUS 括号里是你要添加的内容;</p>
<pre><code>function add($sql){
//连接数据库
$link = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;house&quot;);
//设置编码格式
mysqli_query($link, &quot;set names utf8&quot;);
$res = mysqli_query($link, $sql);

//    $reslut = mysqli_insert_id($link);
//    echo $reslut;die;
if($res){
    return true;    
}else{
    return false;
}
}
</code></pre><p>2、删除</p>
<p>$sql = “DELETE FROM users WHERE id=18”;</p>
<p>WHERE后面是你添加的条件为了更准确的去删除;</p>
<pre><code>function delete($sql){
//连接数据库
$link = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;house&quot;);
mysqli_query($link, &quot;set names utf8&quot;);
$res = mysqli_query($link, $sql);
if($res){
    return true;    
}else{
    return false;
}
}    
</code></pre><p>3、更改<br>    $sql = “UPDATE users SET username=’王’ WHERE id=18”;</p>
<pre><code>function update($sql){
//连接数据库
$link = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;house&quot;);
mysqli_query($link, &quot;set names utf8&quot;);
$res = mysqli_query($link, $sql);
if($res){
    return true;    
}else{
    return false;
}
}
</code></pre><p>4、查询<br>$sql = “SELECT * FROM users”;</p>
<pre><code>function getlist($sql){
//连接数据库
$link = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;house&quot;);
//设置编码格式
mysqli_query($link, &quot;set names utf8&quot;);
//执行sql
$res = mysqli_query($link, $sql);
//取所有数据
//    $list = mysqli_fetch_all($res);//常用
//    $arr = array();
//    while($list = mysqli_fetch_row($res)){
//        $arr[] = $list;
//    }
//常用
while($list = mysqli_fetch_assoc($res)){
    $arr[] = $list;
}

    return $arr;
}
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/03/02/PHP连接sql/" class="archive-article-date">
  	<time datetime="2016-03-02T01:27:22.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-03-02</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-PHP连接sql" data-title="PHP连接sql" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-CSS的垂直居中和水平居中总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/26/CSS的垂直居中和水平居中总结/">CSS的垂直居中和水平居中总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>CSS居中一直是一个比较敏感的话题，为了以后开发的方便，楼主觉得确实需要总结一下了，总的来说，居中问题分为垂直居中和水平居中，实际上水平居中是很简单的，但垂直居中的方式和方法就千奇百怪了
</code></pre><h3 id="内联元素居中方案"><a href="#内联元素居中方案" class="headerlink" title="内联元素居中方案"></a>内联元素居中方案</h3><p>水平居中设置：</p>
<pre><code>1、行内元素 设置 text-align:center；
2、Flex布局 设置display:flex;justify-content:center;(灵活运用)
</code></pre><p>垂直居中设置：</p>
<pre><code>1、父元素高度确定的单行文本（内联元素） 设置 height = line-height；
2、父元素高度确定的多行文本（内联元素） a:插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle； b:先设置 display:table-cell 再设置 vertical-align:middle；
</code></pre><p>块级元素居中方案</p>
<p>水平居中设置：</p>
<pre><code>1、定宽块状元素 设置 左右 margin 值为 auto；

2、不定宽块状元素 a:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto； b:给该元素设置 display:inine 方法； c:父元素设置 position:relative 和 left:50%，子元素设 position:relative 和 left:50%；
</code></pre><p>垂直居中设置：</p>
<p>1.使用position:absolute（fixed）,设置left、top、margin-left、margin-top的属性;</p>
<pre><code>.box{
position:absolute;/*或fixed*/
top:50%;
left:50%;
margin-top:-100px;
margin-left:-200px;
}
</code></pre><p>3.利用display:table-cell属性使内容垂直居中;</p>
<pre><code>.box{
display:table-cell;
vertical-align:middle;
text-align:center;
width:120px;
height:120px;
background:purple;
}
</code></pre><p>4.使用css3的新属性transform:translate(x,y)属性;</p>
<pre><code>.box{
position: absolute;
transform: translate(50%,50%);
-webkit-transform:translate(50%,50%);
-moz-transform:translate(50%,50%);
-ms-transform:translate(50%,50%);
}
</code></pre><p>5.最高大上的一种，使用:before元素;</p>
<pre><code>.box{
position:fixed;
display:block;
background:rgba(0,0,0,.5);
}
.box:before{
content:&apos;&apos;;
display:inline-block;
vertical-align:middle;
height:100%;
}
.box.content{
width:60px;
height:60px;
line-height:60px;
color:red;
</code></pre><p>6.Flex布局;</p>
<pre><code>.box{
display: -webkit-box;
display: -webkit-flex;
display: -moz-box;
display: -moz-flex;
display: -ms-flexbox;
display: flex;
水平居中
-webkit-box-align: center;
-moz-box-align: center;
-ms-flex-pack:center;
-webkit-justify-content: center;
-moz-justify-content: center;
justify-content: center;
 垂直居中
-webkit-box-pack: center;
-moz-box-pack: center;
-ms-flex-align:center;
-webkit-align-items: center;
-moz-align-items: center;
align-items: center;
}    
</code></pre><p>over!    </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/02/26/CSS的垂直居中和水平居中总结/" class="archive-article-date">
  	<time datetime="2016-02-26T03:25:15.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-02-26</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-CSS的垂直居中和水平居中总结" data-title="CSS的垂直居中和水平居中总结" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-前端面试中常见的算术问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/25/前端面试中常见的算术问题/">前端面试中常见的算术问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前端面试中的常见的算法问题"><a href="#前端面试中的常见的算法问题" class="headerlink" title="前端面试中的常见的算法问题"></a>前端面试中的常见的算法问题</h2><pre><code>虽说我们很多时候前端很少有机会接触到算法。大多都交互性的操作，然而从各大公司面试来看，算法依旧是考察的一方面。实际上学习数据结构与算法对于工程师去理解和分析问题都是有帮助的。如果将来当我们面对较为复杂的问题，这些基础知识的积累可以帮助我们更好的优化解决思路。下面罗列在前端面试中经常撞见的几个问题吧
</code></pre><h3 id="Q1-判断一个单词是否是回文？"><a href="#Q1-判断一个单词是否是回文？" class="headerlink" title="Q1 判断一个单词是否是回文？"></a>Q1 判断一个单词是否是回文？</h3><pre><code>回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider .
</code></pre><p>很多人拿到这样的题目非常容易想到用for 将字符串颠倒字母顺序然后匹配就行了。其实重要的考察的就是对于reverse的实现。其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。</p>
<pre><code>function checkPalindrom(str) {  
return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;);
}    
</code></pre><h3 id="Q2-去掉一组整型数组重复的值"><a href="#Q2-去掉一组整型数组重复的值" class="headerlink" title="Q2 去掉一组整型数组重复的值"></a>Q2 去掉一组整型数组重复的值</h3><pre><code>比如输入: [1,13,24,11,11,14,1,2] 
输出: [1,13,24,11,14,2]
需要去掉重复的11 和 1 这两个元素。
</code></pre><p>这道问题出现在诸多的前端面试题中，主要考察个人对Object的使用，利用key来进行筛选。</p>
<pre><code>/**
* unique an array 
**/
let unique = function(arr) {  
let hashTable = {};
let data = [];
for(let i=0,l=arr.length;i&lt;l;i++) {
if(!hashTable[arr[i]]) {
  hashTable[arr[i]] = true;
  data.push(arr[i]);
}
}
return data
}
module.exports = unique;  
</code></pre><h3 id="Q3-统计一个字符串出现最多的字母"><a href="#Q3-统计一个字符串出现最多的字母" class="headerlink" title="Q3 统计一个字符串出现最多的字母"></a>Q3 统计一个字符串出现最多的字母</h3><p>给出一段英文连续的英文字符窜，找出重复出现次数最多的字母</p>
<pre><code>输入 ： afjghdfraaaasdenas 
输出 ： a
</code></pre><p>前面出现过去重的算法，这里需要是统计重复次数。</p>
<pre><code>function findMaxDuplicateChar(str) {  
if(str.length == 1) {
return str;
}
let charObj = {};
for(let i=0;i&lt;str.length;i++) {
if(!charObj[str.charAt(i)]) {
  charObj[str.charAt(i)] = 1;
}else{
  charObj[str.charAt(i)] += 1;
}
}
let maxChar = &apos;&apos;,
  maxValue = 1;
  for(var k in charObj) {
if(charObj[k] &gt;= maxValue) {
  maxChar = k;
  maxValue = charObj[k];
}
}
return maxChar;
}
module.exports = findMaxDuplicateChar;
</code></pre><h3 id="Q4-排序算法"><a href="#Q4-排序算法" class="headerlink" title="Q4 排序算法"></a>Q4 排序算法</h3><p>如果抽到算法题目的话，应该大多都是比较开放的题目，不限定算法的实现，但是一定要求掌握其中的几种，所以冒泡排序，这种较为基础并且便于理解记忆的算法一定需要熟记于心。冒泡排序算法就是依次比较大小，小的的大的进行位置上的交换。</p>
<pre><code>function bubbleSort(arr) {  
for(let i = 0,l=arr.length;i&lt;l-1;i++) {
    for(let j = i+1;j&lt;l;j++) { 
      if(arr[i]&gt;arr[j]) {
            let tem = arr[i];
            arr[i] = arr[j];
            arr[j] = tem;
        }
    }
}
return arr;
}
module.exports = bubbleSort;
</code></pre><p>除了冒泡排序外，其实还有很多诸如 插入排序,快速排序，希尔排序等。每一种排序算法都有各自的特点。全部掌握也不需要，但是心底一定要熟悉几种算法。 比如快速排序，其效率很高，而其基本原理如图(来自wiki)：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="Mou"></p>
<p>算法参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组了</p>
<pre><code>function quickSort(arr) {

if(arr.length&lt;=1) {
    return arr;
}

let leftArr = [];
let rightArr = [];
let q = arr[0];
for(let i = 1,l=arr.length; i&lt;l; i++) {
    if(arr[i]&gt;q) {
        rightArr.push(arr[i]);
    }else{
        leftArr.push(arr[i]);
    }
}

return [].concat(quickSort(leftArr),[q],quickSort(rightArr));
}
module.exports = quickSort;
</code></pre><p>安利大家一个学习的地址，通过动画演示算法的实现。</p>
<p><a href=" ">HTML5 Canvas Demo: Sorting Algorithms</a></p>
<h3 id="Q5-不借助临时变量，进行两个整数的交换"><a href="#Q5-不借助临时变量，进行两个整数的交换" class="headerlink" title="Q5 不借助临时变量，进行两个整数的交换"></a>Q5 不借助临时变量，进行两个整数的交换</h3><pre><code>输入 a = 2, b = 4 输出 a = 4, b =2
</code></pre><p>这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b进行置换。</p>
<p>主要是利用 + - 去进行运算，类似 a = a + ( b - a) 实际上等同于最后 的 a = b;</p>
<pre><code>function swap(a , b) {  
b = b - a;
a = a + b;
b = a - b;
return [a,b];
}
module.exports = swap;    
</code></pre><h3 id="Q6-使用canvas-绘制一个有限度的斐波那契数列的曲线"><a href="#Q6-使用canvas-绘制一个有限度的斐波那契数列的曲线" class="headerlink" title="Q6 使用canvas 绘制一个有限度的斐波那契数列的曲线"></a>Q6 使用canvas 绘制一个有限度的斐波那契数列的曲线</h3><p><img src="http://img1.vued.vanthink.cn/vued90edf7b944ec479ee8b4203cf56e158d.png" alt="Mou"></p>
<p>数列长度限定在9.</p>
<p>斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。我们一般都知道定义</p>
<pre><code>fibo[i] = fibo[i-1]+fibo[i-2];  
</code></pre><p>生成斐波那契数组的方法</p>
<pre><code>function getFibonacci(n) {  
var fibarr = [];
var i = 0;
while(i&lt;n) {
if(i&lt;=1) {
  fibarr.push(i);
}else{
  fibarr.push(fibarr[i-1] + fibarr[i-2])
}
i++;
}
return fibarr;
}
</code></pre><p>剩余的工作就是利用canvas arc方法进行曲线绘制了</p>
<h3 id="Q7-找出下列正数组的最大差值比如"><a href="#Q7-找出下列正数组的最大差值比如" class="headerlink" title="Q7 找出下列正数组的最大差值比如:"></a>Q7 找出下列正数组的最大差值比如:</h3><pre><code>输入 [10,5,11,7,8,9]
输出 6
</code></pre><p>这是通过一道题目去测试对于基本的数组的最大值的查找，很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。</p>
<pre><code>function getMaxProfit(arr) {
var minPrice = arr[0];
var maxProfit = 0;

for (var i = 0; i &lt; arr.length; i++) {
    var currentPrice = arr[i];

    minPrice = Math.min(minPrice, currentPrice);

    var potentialProfit = currentPrice - minPrice;

    maxProfit = Math.max(maxProfit, potentialProfit);
}

return maxProfit;
}    
</code></pre><h3 id="Q8-随机生成指定长度的字符串"><a href="#Q8-随机生成指定长度的字符串" class="headerlink" title="Q8 随机生成指定长度的字符串"></a>Q8 随机生成指定长度的字符串</h3><p>实现一个算法，随机生成指制定长度的字符窜。</p>
<pre><code>比如给定 长度 8  输出 4ldkfg9j


function randomString(n) {  
let str = &apos;abcdefghijklmnopqrstuvwxyz9876543210&apos;;
let tmp = &apos;&apos;,
  i = 0,
  l = str.length;
  for (i = 0; i &lt; n; i++) {
tmp += str.charAt(Math.floor(Math.random() * l));
}
return tmp;
}
module.exports = randomString;
</code></pre><h3 id="Q9-实现类似getElementsByClassName-的功能"><a href="#Q9-实现类似getElementsByClassName-的功能" class="headerlink" title="Q9 实现类似getElementsByClassName 的功能"></a>Q9 实现类似getElementsByClassName 的功能</h3><p>自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供DOM查找函数。</p>
<pre><code>function queryClassName(node, name) {  
var starts = &apos;(^|[ \n\r\t\f])&apos;,
   ends = &apos;([ \n\r\t\f]|$)&apos;;
   var array = [],
    regex = new RegExp(starts + name + ends),
    elements = node.getElementsByTagName(&quot;*&quot;),
    length = elements.length,
    i = 0,
    element;

while (i &lt; length) {
    element = elements[i];
    if (regex.test(element.className)) {
        array.push(element);
    }

    i += 1;
}

return array;
}
</code></pre><h3 id="Q10-使用JS-实现二叉查找树-Binary-Search-Tree"><a href="#Q10-使用JS-实现二叉查找树-Binary-Search-Tree" class="headerlink" title="Q10 使用JS 实现二叉查找树(Binary Search Tree)"></a>Q10 使用JS 实现二叉查找树(Binary Search Tree)</h3><p>一般叫全部写完的概率比较少，但是重点考察你对它的理解和一些基本特点的实现。 二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树：</p>
<pre><code>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

任意节点的左、右子树也分别为二叉查找树；

没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。
</code></pre><p><img src="http://img1.vued.vanthink.cn/vued95685e8f89199babd6273a93651ecd8b.png" alt="Mou">    </p>
<p>在写的时候需要足够理解二叉搜素树的特点，需要先设定好每个节点的数据结构</p>
<pre><code>class Node {  
constructor(data, left, right) {
this.data = data;
this.left = left;
this.right = right;
}
}
</code></pre><p>树是有节点构成，由根节点逐渐延生到各个子节点，因此它具备基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法.</p>
<pre><code>    class BinarySearchTree {
    constructor() {
this.root = null;
}
insert(data) {
let n = new Node(data, null, null);
if (!this.root) {
  return this.root = n;
}
let currentNode = this.root;
let parent = null;
while (1) {
  parent = currentNode;
  if (data &lt; currentNode.data) {
    currentNode = currentNode.left;
    if (currentNode === null) {
      parent.left = n;
      break;
    }
  } else {
    currentNode = currentNode.right;
    if (currentNode === null) {
      parent.right = n;
      break;
    }
  }
}
}

remove(data) {
this.root = this.removeNode(this.root, data)
}

removeNode(node, data) {
if (node == null) {
  return null;
}

if (data == node.data) {
  // no children node
  if (node.left == null &amp;&amp; node.right == null) {
    return null;
  }
  if (node.left == null) {
    return node.right;
  }
  if (node.right == null) {
    return node.left;
  }

  let getSmallest = function(node) {
    if(node.left === null &amp;&amp; node.right == null) {
      return node;
    }
    if(node.left != null) {
      return node.left;
    }
    if(node.right !== null) {
      return getSmallest(node.right);
    }

  }
  let temNode = getSmallest(node.right);
  node.data = temNode.data;
  node.right = this.removeNode(temNode.right,temNode.data);
  return node;

} else if (data &lt; node.data) {
  node.left = this.removeNode(node.left,data);
  return node;
} else {
  node.right = this.removeNode(node.right,data);
  return node;
}
}

find(data) {
var current = this.root;
while (current != null) {
  if (data == current.data) {
    break;
  }
  if (data &lt; current.data) {
    current = current.left;
  } else {
    current = current.right
  }
}
return current.data;
}
}
module.exports = BinarySearchTree;    
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/02/25/前端面试中常见的算术问题/" class="archive-article-date">
  	<time datetime="2016-02-25T13:25:39.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-02-25</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-前端面试中常见的算术问题" data-title="前端面试中常见的算术问题" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-正则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/21/正则/">正则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="1、什么是正则表达式"><a href="#1、什么是正则表达式" class="headerlink" title="1、什么是正则表达式"></a>1、什么是正则表达式</h3><pre><code>正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。
</code></pre><h3 id="2、利用图形化工具理解正则表达式"><a href="#2、利用图形化工具理解正则表达式" class="headerlink" title="2、利用图形化工具理解正则表达式"></a>2、利用图形化工具理解正则表达式</h3><pre><code>辅助理解正则表达的在线工具 https://regexper.com/ 我们利用这个工具辅助理解，正则表达式。语法没懂表着急，后面会有，这里只是学会用工具帮助我们学习。
</code></pre><p>手机号正则</p>
<p>/^1[34578][0-9]{9}$/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/1ce345adabe2cc8b2b96.jpg" alt="Mou">    </p>
<p>注释：以1开头，第二位为3 4 5 7 9 其中一个，以9位（本身1次加重复8次）0-9数字结尾</p>
<h5 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h5><p>/\bis\b/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/3fd0c8d1c0e6614ddffc.jpg" alt="Mou"></p>
<p>注释： is前后都是单词的边界，比较晦涩难懂？感受下两者的区别，\b 会方道语法部分讲解</p>
<p><img src="http://ac-myg6wstv.clouddn.com/a774384e61752ce942a0.jpg" alt="Mou"></p>
<p>URL分组替换</p>
<p>/http:(\/\/.+.jpg)/</p>
<p>看不懂的不要慌语法部分后面会有介绍，这里只是展示利用可视化的图形帮助我们理解正则表达式，可以回来再看木有关系</p>
<p><img src="http://ac-myg6wstv.clouddn.com/72a64c0f5f5ba4e7eaee.jpg" alt="Mou"></p>
<p>正则表达式中括号用来分组，这个时候我们可以通过用$1来获取 group#1的内容</p>
<p><img src="http://ac-myg6wstv.clouddn.com/5c2dbd0ca13e9f444f69.jpg" alt="Mou"></p>
<p>说下这个正则的意义，如果网站用了https，网站引用静态资源也必须是https，否则报错。如果写成 // 会自动识别 http 或者 https</p>
<p>日期匹配与分组替换</p>
<p>/^\d{4}[/-]\d{2}[/-]\d{2}$/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/eeb1d71e254fde06090e.jpg" alt="Mou"></p>
<p>轻松的可以拿到 group#1 #2 #3 的内容，对应 $1 $2 $3</p>
<p><img src="http://ac-myg6wstv.clouddn.com/1a40fca9e0e3e2f2f50d.jpg" alt="Mou"></p>
<p>到现在已经能结合图形化工具看懂正则表达式表达式了，如果想自己写，还要在正则语法上下点功夫</p>
<h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>1 修饰符 （三个 g i m）</p>
<p>修饰符与其他语法特殊，字面量方法声名的时候放到//后，构造函数声明的时候，作为第二个参数传入。整个正则表达式可以理解为正则表达式规则字符串+修饰符</p>
<pre><code>g：global 执行一个全局匹配
i：ignore case执行一个不区分大小写的匹配
m: multiple lines多行匹配
</code></pre><p>修饰符可以一起用 const reg =/\bis\b/gim<br>来说说他们有什么作用<br>有g和没有g的区别</p>
<p><img src="http://ac-myg6wstv.clouddn.com/d7f51998f922e51426cb.jpg" alt="Mou"></p>
<p>没有g只替换了第一个，有g 所有的都换了</p>
<p><img src="http://ac-myg6wstv.clouddn.com/152cde1cd3cd1c4cb63e.jpg" alt="Mou"></p>
<p>有i和没有i的区别</p>
<p><img src="http://ac-myg6wstv.clouddn.com/9048c3bafe0914a065cc.jpg" alt="Mou"></p>
<p>有i忽略大小写，没有i严格区分大小写<br><img src="http://ac-myg6wstv.clouddn.com/bb10c84bef012f611b82.jpg" alt="Mou"></p>
<p>元字符</p>
<p>正则表达式由两种基本字符组成：</p>
<pre><code>原义字符
非打印字符
元字符 (* + ? $ ^ . | \ ( ) { } [ ])
</code></pre><p> 原义字符</p>
<p> 这个没什么好解释的，我们一直在举例的 /is/ 匹配字符串’is’</p>
<p> \将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”</p>
<p>字符类取反 [^]</p>
<h4 id="表示不属于此类"><a href="#表示不属于此类" class="headerlink" title="表示不属于此类"></a>表示不属于此类</h4><p><img src="http://ac-myg6wstv.clouddn.com/2388def90c799b216e5f.jpg" alt="Mou"><br>空格也不属于，好多狗🐶</p>
<p>范围类[-]</p>
<p>正则表达式支持一定范围规则比如 [a-z] [A-Z] [0-9] 可以连写[a-z0-9] 如果你只是想匹配-在 范围类最后加-即可。请看实例。</p>
<p><img src="http://ac-myg6wstv.clouddn.com/546fdd8b997bb4bc88a9.jpg" alt="Mou"></p>
<p> 预定义类</p>
<p>常用为了方便书写</p>
<pre><code>字符        等价类                    含义
.        [^\n\r]                除了回车符和换行符之外的所有字符
\d        [0-9]                数字字符
\D        [^0-9]                非数字字符
\s        [\t\n\x0B\f\r]        空白符
\S        [^\t\n\x0B\f\r]        非空白符
\w        [a-zA-Z_0-9]        单词字符（字母、数字、下划线）
\W        [^a-zA-Z_0-9]        非单词字符
</code></pre><p>有了这些预定义类，写一些正则就很方便了，比如我们希望匹配一个 ab+数字+任意字符 的字符串，就可以这样写了 /ab\d./<br><img src="http://ac-myg6wstv.clouddn.com/13f9df65830c8ab8777a.jpg" alt="Mou"></p>
<p>边界</p>
<pre><code>字符        含义

^        以xx开头
$        以xx结尾
\b        单词边界，指[a-zA-Z_0-9]之外的字符
\B        非单词边界
</code></pre><p>边界顾名思义即定义匹配的边界条件，上面基本都在前面的例子碰到了，这里演示下\b与\B 的区别</p>
<p><img src="http://ac-myg6wstv.clouddn.com/4a401fa730bc568015b7.jpg" alt="Mou"></p>
<p>量词</p>
<pre><code>字符            含义

?        出现零次或一次
*        出现零次或多次(任意次)
+        出现一次或多次（至道一次）
{n}        对应零次或者n次
{n,m}    至少出现n次但不超过m次
{n,}    至少出现n次(+的升级版)
{0,n}    至多出现n次(其实就是{n,m} 方便记忆而已)
</code></pre><p>如果没有量词，要匹配4位数字这样写就可以/\d\d\d\d/, 如果匹配50位100位呢？那不是要疯掉了？<br>有了量词，就可以这样写/\d{100}/, 量词的使用我们在手机号中使用过，表现在可视化中就是循环多少次。</p>
<p>凑一个上面都包含的实例/\d?@\d*@\d+@\d{10}@\d{10,20}@\d{10,}@\d{0,10}/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/92296621793c1e9b289e.jpg" alt="Mou"></p>
<p>贪婪与懒惰（非贪婪）</p>
<p>正则表达式默认会匹配贪婪模式，什么是贪婪模式呢？如其名尽可能多的匹配。我们看个例子🌰。</p>
<p>/\d{3,6}/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/54f23af7ec7334fdf56b.jpg" alt="Mou"></p>
<p><img src="http://ac-myg6wstv.clouddn.com/00f41398667e7d54b4c6.jpg" alt="Mou"></p>
<p>贪婪模式下，匹配的了最多的情况。</p>
<p>与贪婪对应就是懒惰模式，懒惰对应的就是匹配的尽可能少的情况。如何开启懒惰模式？ 在量词后面加?。继续上面的例子</p>
<p>/\d{3,6}?/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/0232a2388ba315d4b197.jpg" alt="Mou"></p>
<p>如果想知道，正则表达式是如何匹配量词的，请看 进阶正则表达式 文中有介绍，正则是如何回溯的。</p>
<p>分组与反向引用</p>
<p>分组，又称为子表达式。把正则表达式拆分成小表达式。概念枯燥，说个例子为嘛用分组：</p>
<p>不分组 /abc{2}/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/20a5e736228756898ec0.jpg" alt="Mou"></p>
<p>量词仅作用到最后的c</p>
<p>分组 /(abc){2}/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/903fec7cc8e8f27b81e6.jpg" alt="Mou"></p>
<p>注意这里 group #1</p>
<p>分组虽然和运算符() 很像，但是分组在正则表达式中，注意理解组的含义。经常有人滥用分组</p>
<p>/^(http|https)/ 真的需要这样么？其实 /^https?/就可以了，你正则写的特别长的时候，会出现一堆没用的结果，看着都头疼吧。</p>
<p>分组往往和反向引用一起使用，别被概念吓到：当一个正则表达式被分组后，每个分组自动被赋予一个组号，一左到右分别是 $1 $2…</p>
<p>再把之前的例子拿出来</p>
<p>/^(\d{4})<a href="\d{2}">/-</a><a href="\d{2}">/-</a>$/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/126a6de5f1367f9f4c5e.jpg" alt="Mou"></p>
<p>轻松的可以拿到 group#1 #2 #3 的内容，对应 $1 $2 $3</p>
<p><img src="http://ac-myg6wstv.clouddn.com/1a40fca9e0e3e2f2f50d.jpg" alt="Mou"></p>
<p>如果在反向引用中不想捕获年该如何操作? 加上 ?:即可</p>
<p>/^(?:\d{4})<a href="\d{2}">/-</a><a href="\d{2}">/-</a>$/</p>
<p><img src="http://ac-myg6wstv.clouddn.com/23ff76b527b991c29faf.jpg" alt="Mou"></p>
<h3 id="over"><a href="#over" class="headerlink" title="over"></a>over</h3>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/01/21/正则/" class="archive-article-date">
  	<time datetime="2016-01-21T11:11:28.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-01-21</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-正则" data-title="正则" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-JavaScript创建对象的7种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/17/JavaScript创建对象的7种方法/">JavaScript创建对象的7种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先解释几个概念：</p>
<pre><code>1、对象 下面例子中所有的Person函数
2、实例/对象实例 通过new Person() or Person()返回的对象，如var person1 = new Person()中的person1
3、原型对象Person.prototype
</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><pre><code>function Person() {
var o = new Object();
o.name = &apos;hanmeimei&apos;;
o.say = function() {
alert(this.name);
}
return o;
}
var person1 = Person();
</code></pre><p>优点：完成了返回一个对象的要求。    </p>
<p>缺点：</p>
<pre><code>1、无法通过constructor识别对象，以为都是来自Object，无法得知来自Person
2、每次通过Person创建对象的时候，所有的say方法都是一样的，但是却存储了多次，浪费资源。
</code></pre><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><pre><code>function Person() {
this.name = &apos;hanmeimei&apos;;
this.say = function() {
alert(this.name)
}
}
var person1 = new Person();    
</code></pre><p>优点：</p>
<pre><code>1、通过constructor或者instanceof可以识别对象实例的类别
2、可以通过new 关键字来创建对象实例，更像OO语言中创建对象实例
</code></pre><p>缺点：</p>
<pre><code>多个实例的say方法都是实现一样的效果，但是却存储了很多次（两个对象实例的say方法是不同的，因为存放的地址不同）
</code></pre><p>注意：</p>
<pre><code>1、构造函数模式隐试的在最后返回return this 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象。
2、也可以根据return this 的特性调用call或者apply指定this。这一点在后面的继承有很大帮助。        
</code></pre><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><pre><code>function Person() {}
Person.prototype.name = &apos;hanmeimei&apos;;
Person.prototype.say = function() {
alert(this.name);
}
Person.prototype.friends = [&apos;lilei&apos;];
var person1 = new Person();
</code></pre><p>优点：</p>
<pre><code>1、say方法是共享的了，所有的实例的say方法都指向同一个。

2、可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。    

var person1 = new Person()
Person.prototype.showFriends = function() {
console.log(this.friends)
}
person1.showFriends()  //[&apos;lilei&apos;]    
</code></pre><p>缺点：</p>
<pre><code>1、出现引用的情况下会出现问题具体见下面代码：

    var person1 = new Person();
    var person2 = new Person();
    person1.friends.push(&apos;xiaoming&apos;);
    console.log(person2.friends)  //[&apos;lilei&apos;, &apos;xiaoming&apos;]

因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。

2、第一次调用say方法或者name属性的时候会搜索两次，第一次是在实例上寻找say方法，没有找到就去原型对象(Person.prototype)上找say方法，找到后就会在实力上添加这些方法or属性。

3、所有的方法都是共享的，没有办法创建实例自己的属性和方法，也没有办法像构造函数那样传递参数。
</code></pre><p>注意：</p>
<pre><code>1、优点②中存在一个问题就是直接通过对象字面量给Person.prototype进行赋值的时候会导致constructor改变，所以需要手动设置，其次就是通过对象字面量给Person.prototype进行赋值，会无法作用在之前创建的对象实例上
var person1 = new Person()
Person.prototype = {
name: &apos;hanmeimei2&apos;,
setName: function(name){
  this.name = name
  }
  }
  person1.setName()   //Uncaught TypeError: person1.set is not a function(…)

  这是因为对象实例和对象原型直接是通过一个指针链接的，这个指针是一个内部属性[[Prototype]]，可以通过__proto__访问。我们通过对象字面量修改了Person.prototype指向的地址，然而对象实例的__proto__，并没有跟着一起更新，所以这就导致，实例还访问着原来的Person.prototype，所以建议不要通过这种方式去改变Person.prototype属性
</code></pre><h3 id="构造函数和原型组合模式"><a href="#构造函数和原型组合模式" class="headerlink" title="构造函数和原型组合模式"></a>构造函数和原型组合模式</h3><pre><code>function Person(name) {
this.name = name
this.friends = [&apos;lilei&apos;]
}
Person.prototype.say = function() {
console.log(this.name)
}
var person1 = new Person(&apos;hanmeimei&apos;)
person1.say() //hanmeimei
</code></pre><p>优点：</p>
<pre><code>1、解决了原型模式对于引用对象的缺点
2、解决了原型模式没有办法传递参数的缺点
3、解决了构造函数模式不能共享方法的缺点
</code></pre><p>缺点：</p>
<pre><code>1、和原型模式中注意①一样
</code></pre><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><pre><code>function Person(name) {
this.name = name
if(typeof this.say != &apos;function&apos;) {
Person.prototype.say = function(
alert(this.name)
}
}
</code></pre><p>优点：</p>
<pre><code>1、可以在初次调用构造函数的时候就完成原型对象的修改
2、修改能体现在所有的实例中
3、缺点：红宝书都说这个方案完美了。。。。
</code></pre><p>注意：</p>
<pre><code>1、只用检查一个在执行后应该存在的方法或者属性就行了
2、不能用对象字面量修改原型对象
</code></pre><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><pre><code>function Person(name) {
var o = new Object()
o.name = name
o.say = function() {
alert(this.name)
}
return o
}
var peron1 = new Person(&apos;hanmeimei&apos;)
</code></pre><p>优点：</p>
<pre><code>1、和工厂模式基本一样，除了多了个new操作符
</code></pre><p>缺点：</p>
<pre><code>2、和工厂模式一样，不能区分实例的类别
</code></pre><h3 id="稳妥构造模式"><a href="#稳妥构造模式" class="headerlink" title="稳妥构造模式"></a>稳妥构造模式</h3><pre><code>function Person(name) {
var o = new Object()
o.say = function() {
alert(name)
}
}
var person1 = new Person(&apos;hanmeimei&apos;);
person1.name  // undefined
person1.say() //hanmeimei
</code></pre><p>优点：</p>
<pre><code>1、安全，那么好像成为了私有变量，只能通过say方法去访问
</code></pre><p>缺点：</p>
<pre><code>1、不能区分实例的类别
</code></pre><p>over!!~~~</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/01/17/JavaScript创建对象的7种方法/" class="archive-article-date">
  	<time datetime="2016-01-17T03:42:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-01-17</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-JavaScript创建对象的7种方法" data-title="JavaScript创建对象的7种方法" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-javascript数据结构-链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/17/javascript数据结构-链表/">javascript数据结构--链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>链表就要来的随性的多，简单的理解可以是这样：在内存中，栈和队列（数组）的存在就是一个整体，如果想要对她内部某一个元素进行移除或是添加一个新元素就要动她内部所有的元素，所谓牵一发而动全身；而链表则不一样，每一个元素都是由元素本身数据和指向下一个元素的指针构成，所以添加或是移除某一个元素不需要对链表整体进行操作，只需要改变相关元素的指针指向就可以了

链表在实际生活中的例子也有很多，比如自行车的链条，环环相扣，但添加或是移除某一个环节只需要对症下药，对相关环节进行操作就OK。再比如：火车，火车就是一个链表，每一节车厢就是元素，想要移除或是添加某一节车厢，只需要把连接车厢的链条改变一下就好了。那么，在javascript中又该怎么去实现链表结构呢？
</code></pre><h2 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h2><p>首先我们要创建一个链表类：</p>
<pre><code>function LinkedList(){
//各种属性和方法的声明
}
</code></pre><p>然后我们需要一种数据结构来保存链表里面的数据：</p>
<pre><code>var Node=function(element){
this.element=element;
this.next=null;}
//Node类表示要添加的元素，他有两个属性，一个是element，表示添加到链表中的具体的值；另一个是next,表示要指向链表中下一个元素的指针。
</code></pre><p>接下来，我们需要给链表声明一些方法：</p>
<pre><code>·append(element):向链表尾部添加一个新的元素；
·insert(position,element):向链表特定位置插入元素；
·remove(element):从链表移除一项；
·indexOf(element):返回链表中某元素的索引，如果没有返回-1；
·removeAt(position):从特定位置移除一项；
·isEmpty():判断链表是否为空，如果为空返回true,否则返回false;
·size():返回链表包含的元素个数；
·toString():重写继承自Object类的toString()方法，因为我们使用了Node类；
</code></pre><p>链表的完整代码：</p>
<pre><code>function LinkedList() {
//Node类声明
let Node = function(element){
    this.element = element;
    this.next = null;
};
//初始化链表长度
let length = 0;
//初始化第一个元素
let head = null;
this.append = function(element){
    //初始化添加的Node实例
    let node = new Node(element),
        current;
    if (head === null){
        //第一个Node实例进入链表，之后在这个LinkedList实例中head就不再是null了
        head = node;
    } else {
        current = head;
        //循环链表知道找到最后一项，循环结束current指向链表最后一项元素
        while(current.next){
            current = current.next;
        }
        //找到最后一项元素后，将他的next属性指向新元素node,j建立链接
        current.next = node;
    }
    //更新链表长度
    length++;
};
this.insert = function(position, element){
    //检查是否越界，超过链表长度或是小于0肯定不符合逻辑的
    if (position &gt;= 0 &amp;&amp; position &lt;= length){
        let node = new Node(element),
            current = head,
            previous,
            index = 0;
        if (position === 0){
            //在第一个位置添加
            node.next = current;
            head = node;
        } else {
            //循环链表，找到正确位置，循环完毕，previous，current分别是被添加元素的前一个和后一个元素
            while (index++ &lt; position){
                previous = current;
                current = current.next;
            }
            node.next = current;
            previous.next = node;
        }
        //更新链表长度
        length++;
        return true;
    } else {
        return false;
    }
};
this.removeAt = function(position){
    //检查是否越界，超过链表长度或是小于0肯定不符合逻辑的
    if (position &gt; -1 &amp;&amp; position &lt; length){
        let current = head,
            previous,
            index = 0;
        //移除第一个元素
        if (position === 0){
            //移除第一项，相当于head=null;
            head = current.next;
        } else {
            //循环链表，找到正确位置，循环完毕，previous，current分别是被添加元素的前一个和后一个元素
            while (index++ &lt; position){
                previous = current;
                current = current.next;
            }
            //链接previous和current的下一个元素，也就是把current移除了
            previous.next = current.next;
        }
        length--;
        return current.element;
    } else {
        return null;
    }
};
this.indexOf = function(element){
    let current = head,
        index = 0;
    //循环链表找到元素位置
    while (current) {
        if (element === current.element) {
            return index;
        }
        index++;
        current = current.next;
    }
    return -1;
};
this.remove = function(element){
    //调用已经声明过的indexOf和removeAt方法
    let index = this.indexOf(element);
    return this.removeAt(index);
};
this.isEmpty = function() {
    return length === 0;
};
this.size = function() {
    return length;
};
this.getHead = function(){
    return head;
};
this.toString = function(){
    let current = head,
        string = &apos;&apos;;
    while (current) {
        string += current.element + (current.next ? &apos;, &apos; : &apos;&apos;);
        current = current.next;
    }
    return string;
};
this.print = function(){
    console.log(this.toString());
};
}

//一个实例化后的链表，里面是添加的数个Node类的实例
</code></pre><p>ES6版本:</p>
<pre><code>let LinkedList2 = (function () {
class Node {
    constructor(element){
        this.element = element;
        this.next = null;
    }
}
//这里我们使用WeakMap对象来记录长度状态
const length = new WeakMap();
const head = new WeakMap();
class LinkedList2 {
    constructor () {
        length.set(this, 0);
        head.set(this, null);
    }
    append(element) {
        let node = new Node(element),
            current;
        if (this.getHead() === null) {
            head.set(this, node);
        } else {
            current = this.getHead();
            while (current.next) {
                current = current.next;
            }
            current.next = node;
        }
        let l = this.size();
        l++;
        length.set(this, l);
    }
    insert(position, element) {
        if (position &gt;= 0 &amp;&amp; position &lt;= this.size()) {

            let node = new Node(element),
                current = this.getHead(),
                previous,
                index = 0;
            if (position === 0) {
                node.next = current;
                head.set(this, node);
            } else {
                while (index++ &lt; position) {
                    previous = current;
                    current = current.next;
                }
                node.next = current;
                previous.next = node;
            }
            let l = this.size();
            l++;
            length.set(this, l);
            return true;
        } else {
            return false;
        }
    }
    removeAt(position) {
        if (position &gt; -1 &amp;&amp; position &lt; this.size()) {
            let current = this.getHead(),
                previous,
                index = 0;
            if (position === 0) {
                head.set(this, current.next);
            } else {
                while (index++ &lt; position) {
                    previous = current;
                    current = current.next;
                }
                previous.next = current.next;
            }
            let l = this.size();
            l--;
            length.set(this, l);
            return current.element;
        } else {
            return null;
        }
    }
    remove(element) {
        let index = this.indexOf(element);
        return this.removeAt(index);
    }
    indexOf(element) {
        let current = this.getHead(),
            index = 0;
        while (current) {
            if (element === current.element) {
                return index;
            }
            index++;
            current = current.next;
        }
        return -1;
    }
    isEmpty() {
        return this.size() === 0;
    }
    size() {
        return length.get(this);
    }
    getHead() {
        return head.get(this);
    }
    toString() {
        let current = this.getHead(),
            string = &apos;&apos;;
        while (current) {
            string += current.element + (current.next ? &apos;, &apos; : &apos;&apos;);
            current = current.next;
        }
        return string;

    }
    print() {
        console.log(this.toString());
    }
}
return LinkedList2;
})();
双向链表
function DoublyLinkedList() {
let Node = function(element){
    this.element = element;
    this.next = null;
    this.prev = null; //NEW
};
let length = 0;
let head = null;
let tail = null; //NEW
this.append = function(element){
    let node = new Node(element),
        current;
    if (head === null){
        head = node;
        tail = node; //NEW
    } else {
        //NEW
        tail.next = node;
        node.prev = tail;
        tail = node;
    }
    length++;
};
this.insert = function(position, element){
    if (position &gt;= 0 &amp;&amp; position &lt;= length){
        let node = new Node(element),
            current = head,
            previous,
            index = 0;
        if (position === 0){
            if (!head){       //NEW
                head = node;
                tail = node;
            } else {
                node.next = current;
                current.prev = node; //NEW
                head = node;
            }
        } else  if (position === length) { ////NEW
            current = tail;   
            current.next = node;
            node.prev = current;
            tail = node;
        } else {
            while (index++ &lt; position){
                previous = current;
                current = current.next;
            }
            node.next = current;
            previous.next = node;
            current.prev = node; //NEW
            node.prev = previous; //NEW
        }
        length++;
        return true;
    } else {
        return false;
    }
};
this.removeAt = function(position){
    if (position &gt; -1 &amp;&amp; position &lt; length){
        let current = head,
            previous,
            index = 0;
        if (position === 0){ //NEW
            if (length === 1){ //
                tail = null;
            } else {
                head.prev = null;
            }
        } else if (position === length-1){  //NEW
            current = tail;
            tail = current.prev;
            tail.next = null;
        } else {
            while (index++ &lt; position){
                previous = current;
                current = current.next;
            }
            previous.next = current.next;
            current.next.prev = previous; //NEW
        }
        length--;
        return current.element;
    } else {
        return null;
    }
};
this.remove = function(element){
    let index = this.indexOf(element);
    return this.removeAt(index);
};
this.indexOf = function(element){
    let current = head,
        index = -1;
    if (element == current.element){
        return 0;
    }
    index++;
    while(current.next){
        if (element == current.element){
            return index;
        }
        current = current.next;
        index++;
    }
    //check last item
    if (element == current.element){
        return index;
    }
    return -1;
};
this.isEmpty = function() {
    return length === 0;
};
this. size = function() {
    return length;
};
this.toString = function(){
    let current = head,
        s = current ? current.element : &apos;&apos;;
    while(current &amp;&amp; current.next){
        current = current.next;
        s += &apos;, &apos; + current.element;
    }
    return s;
};
this.inverseToString = function() {
    let current = tail,
        s = current ? current.element : &apos;&apos;;
    while(current &amp;&amp; current.prev){
        current = current.prev;
        s += &apos;, &apos; + current.element;
    }
    return s;
};
this.print = function(){
    console.log(this.toString());
};
this.printInverse = function(){
    console.log(this.inverseToString());
};
this.getHead = function(){
    return head;
};
this.getTail = function(){
    return tail;
}
}    
</code></pre><p>  双向链表和单项比起来就是Node类多了一个prev属性，也就是每一个node不仅仅有一个指向它后面元素的指针也有一个指向它前面的指针。</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><pre><code>明白了前面的基础链表和双向链表之后这个肯定不在话下了，循环，其实就是整个链表实例变成了一个圈，在单项链表中最后一个元素的next属性为null,现在让它指向第一个元素也就是head，那么他就成了单向循环链表。在双向链表中最后一个元素的next属性为null,现在让它指向第一个元素也就是head，那么他就成了双向循环链表。就那么回事..
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/01/17/javascript数据结构-链表/" class="archive-article-date">
  	<time datetime="2016-01-17T03:05:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-01-17</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-javascript数据结构-链表" data-title="javascript数据结构--链表" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/12/this/">this</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="global-this"><a href="#global-this" class="headerlink" title="global this"></a>global this</h1><p>· 在浏览器，在全局范围内,this等价于window对象.</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2 console.log(this === window); //true
3&lt;/script&gt;
</code></pre><p>· 在浏览器里，在全局范围内，用var声明一个变量和给this或者window添加属性是等价的</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     var foo = &quot;bar&quot;;
3     console.log(this.foo); //logs &quot;bar&quot;
4     console.log(window.foo); //logs &quot;bar&quot;
5 &lt;/script&gt;
</code></pre><p>· 如果你在声明一个变量的时候没有使用var或者let(ECMAScript 6),你就是在给全局的this添加或者改变属性值。</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     foo = &quot;bar&quot;;
3
4     function testThis() {
5       foo = &quot;foo&quot;;
6     }
7
8     console.log(this.foo); //logs &quot;bar&quot;
9     testThis();
10     console.log(this.foo); //logs &quot;foo&quot;
11 &lt;/script&gt;
</code></pre><p>· 在node环境里，如果使用REPL(Read-Eval-Print Loop，简称REPL:读取-求值-输出,是一个简单的，交互式的编程环境)来执行程序,this并不是最高级的命名空间，最高级的是global.</p>
<pre><code>&gt; this
{ ArrayBuffer: [Function: ArrayBuffer],
Int8Array: { [Function: Int8Array] BYTES_PER_ELEMENT: 1 },
...
&gt; global === this
true
</code></pre><p>· 在node环境里，如果执行一个js脚本，在全局范围内，this以一个空对象开始作为最高级的命名空间，这个时候，它和global不是等价的。</p>
<pre><code>1 test.js脚本内容：
2
3 console.log(this);
4 console.log(this === global);
5 
6 REPL运行脚本：
7 
8 $ node test.js
9 {}
10 false
</code></pre><p>· 在node环境里，在全局范围内，如果你用REPL执行一个脚本文件，用var声明一个变量并不会和在浏览器里面一样将这个变量添加给this。</p>
<pre><code>1 test.js:
2 
3 var foo = &quot;bar&quot;;
4 console.log(this.foo);
5 
6 $ node test.js
7 undefined    
</code></pre><p>· 但是如果你不是用REPL执行脚本文件，而是直接执行代码，结果和在浏览器里面是一样的(神坑)</p>
<pre><code>1 &gt; var foo = &quot;bar&quot;;
2 &gt; this.foo
3 bar
4 &gt; global.foo
5 bar
</code></pre><p>· 在node环境里，用REPL运行脚本文件的时候，如果在声明变量的时候没有使用var或者let，这个变量会自动添加到global对象，但是不会自动添加给this对象。如果是直接执行代码，则会同时添加给global和this</p>
<pre><code>1 test.js
2 
3 foo = &quot;bar&quot;;
4 console.log(this.foo);
5 console.log(global.foo);
6 
7 $ node test.js
8 undefined
9 bar


上面的八种情况可能大家已经绕晕了，总结起来就是：在浏览器里面this是老大，它等价于window对象，如果你声明一些全局变量(不管在任何地方)，这些变量都会作为this的属性。在node里面，有两种执行JavaScript代码的方式，一种是直接执行写好的JavaScript文件，另外一种是直接在里面执行一行行代码。对于直接运行一行行JavaScript代码的方式，global才是老大，this和它是等价的。在这种情况下，和浏览器比较相似，也就是声明一些全局变量会自动添加给老大global，顺带也会添加给this。但是在node里面直接脚本文件就不一样了，你声明的全局变量不会自动添加到this，但是会添加到global对象。所以相同点是，在全局范围内，全局变量终究是属于老大的。
</code></pre><h1 id="function-this"><a href="#function-this" class="headerlink" title="function this"></a>function this</h1><p>· 无论是在浏览器环境还是node环境， 除了在DOM事件处理程序里或者给出了thisArg(接下来会讲到)外，如果不是用new调用，在函数里面使用this都是指代全局范围的this。</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     foo = &quot;bar&quot;;
3 
4     function testThis() {
5       this.foo = &quot;foo&quot;;
6     }
7 
8     console.log(this.foo); //logs &quot;bar&quot;
9     testThis();
10     console.log(this.foo); //logs &quot;foo&quot;
11 &lt;/script&gt;

test.js

foo = &quot;bar&quot;;

function testThis () {
this.foo = &quot;foo&quot;;
}
console.log(global.foo);
testThis();console.log(global.foo);
$ node test.js
bar
foo    
</code></pre><p>· 除非你使用严格模式，这时候this就会变成undefined。</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     foo = &quot;bar&quot;;
3 
4     function testThis() {
5       &quot;use strict&quot;;
6       this.foo = &quot;foo&quot;;
7     }
8 
9     console.log(this.foo); //logs &quot;bar&quot;
10     testThis();  //Uncaught TypeError: Cannot set property &apos;foo&apos; of undefined 
11 &lt;/script&gt;
</code></pre><p>· 如果你在调用函数的时候在前面使用了new，this就会变成一个新的值，和global的this脱离干系.</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     foo = &quot;bar&quot;;
3 
4     function testThis() {
5       this.foo = &quot;foo&quot;;
6     }
7 
8     console.log(this.foo); //logs &quot;bar&quot;
9     new testThis();
10     console.log(this.foo); //logs &quot;bar&quot;
11 
12     console.log(new testThis().foo); //logs &quot;foo&quot;
13 &lt;/script&gt;
</code></pre><p>我更喜欢把新的值称作一个实例。</p>
<pre><code>函数里面的this其实相对比较好理解，如果我们在一个函数里面使用this，需要注意的就是我们调用函数的方式，如果是正常的方式调用函数，this指代全局的this，如果我们加一个new，这个函数就变成了一个构造函数，我们就创建了一个实例，this指代这个实例，这个和其他面向对象的语言很像。另外，写JavaScript很常做的一件事就是绑定事件处理程序，也就是诸如button.addEventListener(‘click’, fn, false)之类的，如果在fn里面需要使用this，this指代事件处理程序对应的对象，也就是button。
</code></pre><h1 id="Protoype-this"><a href="#Protoype-this" class="headerlink" title="Protoype this"></a>Protoype this</h1><p>你创建的每一个函数都是函数对象。它们会自动获得一个特殊的属性prototype，你可以给这个属性赋值。当你用new的方式调用一个函数的时候，你就能通过this访问你给prototype赋的值了。</p>
<pre><code>1 function Thing() {
2       console.log(this.foo);
3 }
4 
5 Thing.prototype.foo = &quot;bar&quot;;
6 
7 var thing = new Thing(); //logs &quot;bar&quot;
8 console.log(thing.foo);  //logs &quot;bar&quot;
</code></pre><p>当你使用new为你的函数创建多个实例的时候，这些实例会共享你给prototype设定的值。对于下面的例子，当你调用this.foo的时候，都会返回相同的值，除非你在某个实例里面重写了自己的this.foo</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     console.log(this.foo);
6 }
7 Thing.prototype.setFoo = function (newFoo) {
8     this.foo = newFoo;
9 }
10 
11 var thing1 = new Thing();
12 var thing2 = new Thing();
13 
14 thing1.logFoo(); //logs &quot;bar&quot;
15 thing2.logFoo(); //logs &quot;bar&quot;
16 
17 thing1.setFoo(&quot;foo&quot;);
18 thing1.logFoo(); //logs &quot;foo&quot;;
19 thing2.logFoo(); //logs &quot;bar&quot;;
20 
21 thing2.foo = &quot;foobar&quot;;
22 thing1.logFoo(); //logs &quot;foo&quot;;
23 thing2.logFoo(); //logs &quot;foobar&quot;;
</code></pre><p>实例里面的this是一个特殊的对象。你可以把this想成一种获取prototype的值的一种方式。当你在一个实例里面直接给this添加属性的时候，会隐藏prototype中与之同名的属性。如果你想访问prototype中的这个属性值而不是你自己设定的属性值，你可以通过在实例里面删除你自己添加的属性的方式来实现</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     console.log(this.foo);
6 }
7 Thing.prototype.setFoo = function (newFoo) {
8     this.foo = newFoo;
9 }
10 Thing.prototype.deleteFoo = function () {
11     delete this.foo;
12 }
13 var thing = new Thing();
14 thing.setFoo(&quot;foo&quot;);
15 thing.logFoo(); //logs &quot;foo&quot;;
16 thing.deleteFoo();
17 thing.logFoo(); //logs &quot;bar&quot;;
18 thing.foo = &quot;foobar&quot;;
19 thing.logFoo(); //logs &quot;foobar&quot;;
20 delete thing.foo;
21 thing.logFoo(); //logs &quot;bar&quot;;
</code></pre><p>或者你也能直接通过引用函数对象的prototype 来获得你需要的值</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     console.log(this.foo, Thing.prototype.foo);
6 }
7 
8 var thing = new Thing();
9 thing.foo = &quot;foo&quot;;
10 thing.logFoo(); //logs &quot;foo bar&quot;;
</code></pre><p>给一个函数的prototype赋值一个Array通常是一个错误的做法。如果你想每一个实例有他们专属的Array，你应该在函数里面创建而不是在prototype里面创建。</p>
<pre><code>1 function Thing() {
2     this.things = [];
3 }
4 
5 
6 var thing1 = new Thing();
7 var thing2 = new Thing();
8 thing1.things.push(&quot;foo&quot;);
9 console.log(thing1.things); //logs [&quot;foo&quot;]
10 console.log(thing2.things); //logs []
</code></pre><p>实际上你可以通过把多个函数的prototype链接起来的从而形成一个原型链，因此this就会魔法般地沿着这条原型链往上查找直到找你你需要引用的值。</p>
<pre><code>1 function Thing1() {
2 }
3 Thing1.prototype.foo = &quot;bar&quot;;
4 
5 function Thing2() {
6 }
7 Thing2.prototype = new Thing1();
8 
9 
10 var thing = new Thing2();
11 console.log(thing.foo); //logs &quot;bar&quot;          
</code></pre><p>一些人利用原型链的特性来在JavaScript模仿经典的面向对象的继承方式。任何给用于构建原型链的函数的this的赋值的语句都会隐藏原型链上游的相同的属性</p>
<pre><code>1 function Thing1() {
2 }
3 Thing1.prototype.foo = &quot;bar&quot;;
4 
5 function Thing2() {
6     this.foo = &quot;foo&quot;;
7 }
8 Thing2.prototype = new Thing1();
9 
10 function Thing3() {
11 }
12 Thing3.prototype = new Thing2();
13 
14 
15 var thing = new Thing3();
16 console.log(thing.foo); //logs &quot;foo&quot;
</code></pre><p>我喜欢把被赋值给prototype的函数叫做方法。在上面的例子中，我已经使用过方法了，如logFoo。这些方法有着相同的prototype，即创建这些实力的原始函数。我通常把这些原始函数叫做构造函数。在prototype里面定义的方法里面使用this会影响到当前实例的原型链的上游的this。这意味着你直接给this赋值的时候，隐藏了原型链上游的相同的属性值。这个实例的任何方法都会使用这个最新的值而不是原型里面定义的这个相同的值。</p>
<pre><code>1 function Thing1() {
2 }
3 Thing1.prototype.foo = &quot;bar&quot;;
4 Thing1.prototype.logFoo = function () {
5     console.log(this.foo);
6 }
7 
8 function Thing2() {
9     this.foo = &quot;foo&quot;;
10 }
11 Thing2.prototype = new Thing1();
12 
13 
14 var thing = new Thing2();
15 thing.logFoo(); //logs &quot;foo&quot;;
</code></pre><p>在JavaScript里面你可以嵌套函数，也就是你可以在函数里面定义函数。嵌套函数可以通过闭包捕获父函数的变量，但是这个函数没有继承this</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     var info = &quot;attempting to log this.foo:&quot;;
6     function doIt() {
7         console.log(info, this.foo);
8     }
9     doIt();
10 }
11 
12 
13 var thing = new Thing();
14 thing.logFoo();  //logs &quot;attempting to log this.foo: undefined&quot;
</code></pre><p>在doIt里面的this是global对象或者在严格模式下面是undefined。这是造成很多不熟悉JavaScript的人深陷 this陷阱的根源。在这种情况下事情变得非常糟糕，就像你把一个实例的方法当作一个值，把这个值当作函数参数传递给另外一个函数但是却不把这个实例传递给这个函数一样。在这种情况下，一个方法里面的环境变成了全局范围，或者在严格模式下面的undefined。</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {  
5     console.log(this.foo);   
6 }
7 
8 function doIt(method) {
9     method();
10 }
11 
12 
13 var thing = new Thing();
14 thing.logFoo(); //logs &quot;bar&quot;
15 doIt(thing.logFoo); //logs undefined
</code></pre><p>你可以通过bind将实例和方法一切传递给函数来解决这个问题，bind是一个函数定义在所有函数和方法的函数对象上面</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () { 
5     console.log(this.foo);
6 }
7 
8 function doIt(method) {
9     method();
10 }
11 
12 
13 var thing = new Thing();
14 doIt(thing.logFoo.bind(thing)); //logs bar
</code></pre><p>你同样可以使用apply和call来在新的上下文中调用方法或函数。</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () { 
5     function doIt() {
6         console.log(this.foo)
7     }
8     doIt.apply(this);
9 }
10 
11 function doItIndirectly(method) {
12     method();
13 }
14 
15 
16 var thing = new Thing();
17 doItIndirectly(thing.logFoo.bind(thing)); //logs bar
</code></pre><p>你可以用bind来代替任何一个函数或者方法的this，即便它没有赋值给实例的初始prototype。</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 
5 
6 function logFoo(aStr) {
7     console.log(aStr, this.foo);
8 }
9 
10 
11 var thing = new Thing();
12 logFoo.bind(thing)(&quot;using bind&quot;); //logs &quot;using bind bar&quot;
13 logFoo.apply(thing, [&quot;using apply&quot;]); //logs &quot;using apply bar&quot;
14 logFoo.call(thing, &quot;using call&quot;); //logs &quot;using call bar&quot;
15 logFoo(&quot;using nothing&quot;); //logs &quot;using nothing undefined&quot;    
</code></pre><p>你应该避免在构造函数里面返回任何东西，因为这可能代替本来应该返回的实例.</p>
<pre><code>1 function Thing() {
2     return {};
3 }
4 Thing.prototype.foo = &quot;bar&quot;;
5 
6 
7 Thing.prototype.logFoo = function () {
8     console.log(this.foo);
9 }
10 
11 
12 var thing = new Thing();
13 thing.logFoo(); //Uncaught TypeError: undefined is not a function
</code></pre><p>奇怪的是，如果你在构造函数里面返回了一个原始值，上面所述的情况并不会发生并且返回语句被忽略了。最好不要在你将通过new调用的构造函数里面返回任何类型的数据，即便你知道自己正在做什么。如果你想创建一个工厂模式，通过一个函数来创建一个实例，这个时候不要使用new来调用函数。当然这个建议是可选的。<br>    你可以通过使用Object.create来避免使用new，这样同样能够创建一个实例。</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 
5 
6 Thing.prototype.logFoo = function () {
7     console.log(this.foo);
8 }
9 
10 
11 var thing =  Object.create(Thing.prototype);
12 thing.logFoo(); //logs &quot;bar&quot;     
</code></pre><p>在这种情况下并不会调用构造函数</p>
<pre><code>1 function Thing() {
2     this.foo = &quot;foo&quot;;
3 }
4 Thing.prototype.foo = &quot;bar&quot;;
5 
6 
7 Thing.prototype.logFoo = function () {
8     console.log(this.foo);
9 }
10 
11 
12 var thing =  Object.create(Thing.prototype);
13 thing.logFoo(); //logs &quot;bar&quot;    
</code></pre><p>因为Object.create不会调用构造函数的特性在你继承模式下你想通过原型链重写构造函数的时候非常有用。</p>
<pre><code>1 function Thing1() {
2     this.foo = &quot;foo&quot;;
3 }
4 Thing1.prototype.foo = &quot;bar&quot;;
5 
6 function Thing2() {
7     this.logFoo(); //logs &quot;bar&quot;
8     Thing1.apply(this);
9     this.logFoo(); //logs &quot;foo&quot;
10 }
11 Thing2.prototype = Object.create(Thing1.prototype);
12 Thing2.prototype.logFoo = function () {
13     console.log(this.foo);
14 }
15 
16 var thing = new Thing2();
</code></pre><h1 id="DOM-event-this"><a href="#DOM-event-this" class="headerlink" title="DOM event this"></a>DOM event this</h1><p>在一个HTML DOM事件处理程序里面，this始终指向这个处理程序被所绑定到的HTML DOM节点</p>
<pre><code>1 function Listener()     {
2 document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;,
3        this.handleClick);
4 }
5 Listener.prototype.handleClick = function (event) {
6     console.log(this); //logs &quot;&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;&quot;
7 }
8 
9 var listener = new Listener();
10 document.getElementById(&quot;foo&quot;).click();
</code></pre><p>除非你自己通过bind切换了上下文</p>
<pre><code>1 function Listener() {
2     document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;, 
3         this.handleClick.bind(this));
4 }
5 Listener.prototype.handleClick = function (event) {
6     console.log(this); //logs Listener {handleClick: function}
7 }
8 
9 var listener = new Listener();
10 document.getElementById(&quot;foo&quot;).click();
</code></pre><h1 id="HTML-this"><a href="#HTML-this" class="headerlink" title="HTML this"></a>HTML this</h1><p>在HTML节点的属性里面，你可以放置JavaScript代码，this指向了这个元素</p>
<pre><code>1 &lt;div id=&quot;foo&quot; onclick=&quot;console.log(this);&quot;&gt;&lt;/div&gt;
2 &lt;script type=&quot;text/javascript&quot;&gt;
3 document.getElementById(&quot;foo&quot;).click(); //logs &lt;div id=&quot;foo&quot;...
4 &lt;/script&gt;
</code></pre><h1 id="override-this"><a href="#override-this" class="headerlink" title="override this"></a>override this</h1><p>你不能重写this，因为它是保留字。</p>
<pre><code>function Thing () {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {
eval(&quot;console.log(this.foo)&quot;); //logs &quot;bar&quot;
}
var thing = new Thing();
thing.logFoo();    
</code></pre><h1 id="with-this"><a href="#with-this" class="headerlink" title="with this"></a>with this</h1><p>你可以通过with来将this添加到当前的执行环境，并且读写this的属性的时候不需要通过this</p>
<pre><code>1 function Thing () {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     with (this) {
6         console.log(foo);
7         foo = &quot;foo&quot;;
8     }
9 }
10 
11 var thing = new Thing();
12 thing.logFoo(); // logs &quot;bar&quot;
13 console.log(thing.foo); // logs &quot;foo&quot;    
</code></pre><h1 id="jQuery-this"><a href="#jQuery-this" class="headerlink" title="jQuery this"></a>jQuery this</h1><p>和HTML DOM元素节点的事件处理程序一样，在许多情况下JQuery的this都指向HTML元素节点。这在事件处理程序和一些方便的方法中都是管用的，比如$.each</p>
<pre><code>1 &lt;div class=&quot;foo bar1&quot;&gt;&lt;/div&gt;
2 &lt;div class=&quot;foo bar2&quot;&gt;&lt;/div&gt;
3 &lt;script type=&quot;text/javascript&quot;&gt;
4 $(&quot;.foo&quot;).each(function () {
5     console.log(this); //logs &lt;div class=&quot;foo...
6 });
7 $(&quot;.foo&quot;).on(&quot;click&quot;, function () {
8     console.log(this); //logs &lt;div class=&quot;foo...
9 });
10 $(&quot;.foo&quot;).each(function () {
11     this.click();
12 });
13 &lt;/script&gt;
</code></pre><h1 id="thisArg-this"><a href="#thisArg-this" class="headerlink" title="thisArg this"></a>thisArg this</h1><p>如果你用过underscore.js 或者 lo-dash 你可能知道许多类库的方法可以通过一个叫做thisArg 的函数参数来传递实例，这个函数参数会作为this的上下文。举个例子，这适用于_.each。原生的JavaScript在ECMAScript 5的时候也允许函数传递一个thisArg参数了，比如forEach。事实上，之前阐述的bind，apply和call的使用已经给你创造了传递thisArg参数给函数的机会。这个参数将this绑定为你所传递的对象。</p>
<pre><code>1 function Thing(type) {
2     this.type = type;
3 }
4 Thing.prototype.log = function (thing) {
5     console.log(this.type, thing);
6 }
7 Thing.prototype.logThings = function (arr) {
8    arr.forEach(this.log, this); // logs &quot;fruit apples...&quot;
9    _.each(arr, this.log, this); //logs &quot;fruit apples...&quot;
10 }
11 
12 var thing = new Thing(&quot;fruit&quot;);
13 thing.logThings([&quot;apples&quot;, &quot;oranges&quot;,
&quot;strawberries&quot;, &quot;bananas&quot;]);         
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/01/12/this/" class="archive-article-date">
  	<time datetime="2016-01-12T06:32:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-01-12</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-this" data-title="this" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-boke" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/11/boke/">boke</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="gulp详细入门教程"><a href="#gulp详细入门教程" class="headerlink" title="gulp详细入门教程"></a>gulp详细入门教程</h1><p>最近使用gulp自动化构建工具来开发网站，在此给大家分享下使用gulp的一些使用教程。</p>
<p>一 gulp安装</p>
<p>1、安装Nodejs</p>
<pre><code>1.1、说明:gulp是基于nodejs，理所当然需要安装Nodejs
1.2、安装:打开nodejs官网,点击绿色下载按钮，它会根据系统信息选择对应(.msi文件).
</code></pre><p>2、全局安装gulp</p>
<pre><code>2、1    说明:说明全局安装gulp目的是为了通过她只想gulp任务;
2、2安装:命令提示符执行npm install gulp-g;
2、3查看是否正确安装:命令提示符执行gulp-v,出现版本号为安装成功
</code></pre><p>3、新建package.json文件</p>
<pre><code>3、1 说明:package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件;
3、2 执行命令提示符执行npm init进行手动安装
3.3 安装完成后回在当前文件夹下看到如下package.json
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3164024-76d2e9fa62a00632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mou"><br>    文件说明：</p>
<pre><code>&quot;name&quot;:&quot;test&quot;,//项目名称（必须）
&quot;version&quot;:1.0.0,//项目版本（必须）
&quot;description&quot;:&quot;This is for study gulp             “project !&quot;,//项目描述（必须）
&quot;devDependencies&quot;:{//项目依赖的插件
3.4、查看package.json帮助文档，命令提示符执行npm help package.json
</code></pre><p>4、安装本地gulp及其常用插件</p>
<pre><code>4.1、执行命令行npm install gulo 安装本地gulp
4.2、安装gulo插件:以gulp-sass为例:
    执行名npm install gulp-sass即可安装gulp-sass插件，安装完成后即可在node_modules文件夹下查看到新安装的插件
</code></pre><p>5、新建gulpfile.js文件（必须）</p>
<pre><code>5.1、说明:gulpfile.js是gulp项目目的配置文件,是位于项目根目录的普通js文件（其实将gulp.js放入其他文件夹下也是可以的）
5.2、gulpfile.js文件用法（以gulp-sass为例）
    5.2.1    导入工具包require(&apos;node_modules里对应模块&apos;)
        var gulp=require(&apos;gulp&apos;)
        var less=require(&apos;gulp-less);
    5.2、定义一个testLess任务（自定义任务名称）
        gulp.task(&apos;testLess&apos;,function(){
        gulp.src(&apos;src/less/index.less&apos;)//该任务针对的文件
        .pipe(less())//该任务调用的模块
        .pipe(gulp.dest(&apos;src/css&apos;));/将会在src/css下生成index.css
        })
        gulp.task(&apos;default&apos;,[&apos;watch&apos;],function(){
        //定义默认任务 并让gulp监视文件变化自动执行
        gulp.watch(&apos;sass/*.scss&apos;,[&apos;sass&apos;])
        })
</code></pre><h1 id="二、gulp常用插件"><a href="#二、gulp常用插件" class="headerlink" title="二、gulp常用插件"></a>二、gulp常用插件</h1><p>  1、gulp-uglify(js压缩)<br>安装：npm install –save-dev gulp-uglify</p>
<pre><code>gulpfile.js代码如下:

var gulp = require(&apos;gulp&apos;),
var rename= require(&apos;gulp-rename&apos;)
var uglify= require(&quot;gulp-uglify&quot;);
gulp.task(&apos;rename&apos;,function() {
gulp.src(&apos;src/**/*.js&apos;)
.pipe(uglify())//压缩
.pipe(rename(&apos;index.min.js&apos;))    
.pipe(gulp.dest(&apos;build/js&apos;));});
gulp.task(&apos;default&apos;,[&apos;rename&apos;]);    
uglify= require(&quot;gulp-uglify&quot;);
</code></pre><p>2、gulp-minify-html（html压缩）<br>安装：npm install –save-dev gulp-minify-html</p>
<p>代码如下：    </p>
<pre><code>var gulp = require(&apos;gulp&apos;),
var minifyHtml= require(&quot;gulp-minify-html&quot;);
gulp.task(&apos;minify-html&apos;,function() {
gulp.src(&apos;src/**/*.html&apos;)//要压缩的html文件
 .pipe(minifyHtml())//压缩
 .pipe(gulp.dest(&apos;build&apos;));});
 gulp.task(&apos;default&apos;,[&apos;minify-html&apos;]);
</code></pre><p>3、 gulp-concat (js文件合并)</p>
<p>安装：npm install –save-dev gulp-concat</p>
<p>代码如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
concat= require(&quot;gulp-concat&quot;);
gulp.task(&apos;concat&apos;,function() {
gulp.src(&apos;src/**/*.js&apos;)  //要合并的文件
.pipe(concat(&apos;index.js&apos;))  //合并匹配到的js文件并命名为 &quot;index.js&quot;
 .pipe(gulp.dest(&apos;build/js&apos;));});
 gulp.task(&apos;default&apos;,[&apos;concat&apos;]);
</code></pre><p>4、gulp-jada</p>
<p>安装：npm install –save-dev  gulp-jada</p>
<p>Gulpfile.js代码如下：</p>
<pre><code>var gulp= require(&apos;gulp&apos;);
var jade= require(&apos;gulp-jade&apos;);
gulp.task(&quot;jade&quot;,function(){
gulp.src(&quot;./jade/*.jade&quot;)
 .pipe(jade({
 pretty:true
 }))
  .pipe(gulp.dest(&quot;html/&quot;))
  })
   gulp.task(&quot;default&quot;,[&quot;watch&quot;],function(){
    gulp.watch(&quot;jade/*.jade&quot;,[&quot;jade&quot;]);
    })
</code></pre><p>5、gulp-less        </p>
<p>安装：npm install –save-dev  gulp-less</p>
<p>Gulpfile.js代码如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
var less= require(&quot;gulp-less&quot;);
gulp.task(&apos;compile-less&apos;,function() {
 gulp.src(&apos;src/less/*.less&apos;)
  .pipe(less())
   .pipe(gulp.dest(&apos;build/css&apos;));
   });
   gulp.task(&apos;default&apos;,[&apos;compile-less&apos;]);
</code></pre><p>6、gulp-sass</p>
<p>安装：npm install –save-dev  gulp-sass</p>
<p>代码如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
var sass= require(&quot;gulp-sass&quot;);
gulp.task(&apos;compile-sass&apos;,function() {
 gulp.src(&apos;src/sass/*.sass&apos;)
 .pipe(sass())
  .pipe(gulp.dest(&apos;build/css&apos;));
  });
  gulp.task(&apos;default&apos;,[&apos;compile-sass&apos;]);
</code></pre><p>7、gulp-imagemin（图片压缩</p>
<p>安装：npm install –save-dev  gulp-imagemin</p>
<p>代码如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;);
var imagemin = require(&apos;gulp-imagemin&apos;);
gulp.task(&apos;uglify-imagemin&apos;,function()    {returngulp.src(&apos;src/images/*&apos;)
.pipe(imagemin())
 .pipe(gulp.dest(&apos;build/images&apos;));
 });
 gulp.task(&apos;default&apos;,[&apos;uglify-imagemin&apos;]);
</code></pre><p>8、理解Browserify</p>
<p>browserify是一个使用node支持的CommonJS模块标准 来为浏览器编译模块的，可以解决模块及依赖管理；</p>
<p>先来看看使用gulp常见的问题：</p>
<p>1、 使用 gulp 过程中，偶尔会遇到 Streaming not supported 这样的错误。这通常是因为常规流与 vinyl 文件对象流有差异、<br>gulp 插件默认使用了只支持 buffer （不支持 stream）的库。比如，不能把 Node 常规流直接传递给 gulp 及其插件。</p>
<p>比如如下代码：会抛出异常的；</p>
<pre><code>vargulp = require(&apos;gulp&apos;);
varuglify = require(&apos;gulp-uglify&apos;);
varconcat = require(&apos;gulp-concat&apos;);
varrename = require(&apos;gulp-rename&apos;);varfs = require(&apos;fs&apos;);
gulp.task(&apos;bundle&apos;,function() {returnfs.createReadStream(&apos;./test.txt&apos;)
.pipe(uglify())
.pipe(rename(&apos;bundle.min.js&apos;))
 .pipe(gulp.dest(&apos;dist/&apos;));
 });
 gulp.task(&apos;default&apos;,[&apos;bundle&apos;]);
</code></pre><p>希望能帮助到你们~~            </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/01/11/boke/" class="archive-article-date">
  	<time datetime="2016-01-11T13:26:36.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-01-11</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-boke" data-title="boke" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 特仑苏
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>