<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>高乐高</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="高乐高">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="高乐高">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高乐高">
  
    <link rel="alternative" href="/atom.xml" title="高乐高" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars2.githubusercontent.com/u/20942807?v=3&amp;u=29f58348a0cff3578d3647fba8fb54bc86186c1e&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">特仑苏</a></h1>
		</hgroup>

		
		<p class="header-subtitle">只有努力才能得到自己想要的东西</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/wzj1996/wzj1996.github.io.git" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/3137128535" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">特仑苏</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars2.githubusercontent.com/u/20942807?v=3&amp;u=29f58348a0cff3578d3647fba8fb54bc86186c1e&amp;s=140" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">特仑苏</h1>
			</hgroup>
			
			<p class="header-subtitle">只有努力才能得到自己想要的东西</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wzj1996/wzj1996.github.io.git" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3137128535" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-JavaScript创建对象的7种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/17/JavaScript创建对象的7种方法/">JavaScript创建对象的7种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先解释几个概念：</p>
<pre><code>1、对象 下面例子中所有的Person函数
2、实例/对象实例 通过new Person() or Person()返回的对象，如var person1 = new Person()中的person1
3、原型对象Person.prototype
</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><pre><code>function Person() {
var o = new Object();
o.name = &apos;hanmeimei&apos;;
o.say = function() {
alert(this.name);
}
return o;
}
var person1 = Person();
</code></pre><p>优点：完成了返回一个对象的要求。    </p>
<p>缺点：</p>
<pre><code>1、无法通过constructor识别对象，以为都是来自Object，无法得知来自Person
2、每次通过Person创建对象的时候，所有的say方法都是一样的，但是却存储了多次，浪费资源。
</code></pre><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><pre><code>function Person() {
this.name = &apos;hanmeimei&apos;;
this.say = function() {
alert(this.name)
}
}
var person1 = new Person();    
</code></pre><p>优点：</p>
<pre><code>1、通过constructor或者instanceof可以识别对象实例的类别
2、可以通过new 关键字来创建对象实例，更像OO语言中创建对象实例
</code></pre><p>缺点：</p>
<pre><code>多个实例的say方法都是实现一样的效果，但是却存储了很多次（两个对象实例的say方法是不同的，因为存放的地址不同）
</code></pre><p>注意：</p>
<pre><code>1、构造函数模式隐试的在最后返回return this 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象。
2、也可以根据return this 的特性调用call或者apply指定this。这一点在后面的继承有很大帮助。        
</code></pre><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><pre><code>function Person() {}
Person.prototype.name = &apos;hanmeimei&apos;;
Person.prototype.say = function() {
alert(this.name);
}
Person.prototype.friends = [&apos;lilei&apos;];
var person1 = new Person();
</code></pre><p>优点：</p>
<pre><code>1、say方法是共享的了，所有的实例的say方法都指向同一个。

2、可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。    

var person1 = new Person()
Person.prototype.showFriends = function() {
console.log(this.friends)
}
person1.showFriends()  //[&apos;lilei&apos;]    
</code></pre><p>缺点：</p>
<pre><code>1、出现引用的情况下会出现问题具体见下面代码：

    var person1 = new Person();
    var person2 = new Person();
    person1.friends.push(&apos;xiaoming&apos;);
    console.log(person2.friends)  //[&apos;lilei&apos;, &apos;xiaoming&apos;]

因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。

2、第一次调用say方法或者name属性的时候会搜索两次，第一次是在实例上寻找say方法，没有找到就去原型对象(Person.prototype)上找say方法，找到后就会在实力上添加这些方法or属性。

3、所有的方法都是共享的，没有办法创建实例自己的属性和方法，也没有办法像构造函数那样传递参数。
</code></pre><p>注意：</p>
<pre><code>1、优点②中存在一个问题就是直接通过对象字面量给Person.prototype进行赋值的时候会导致constructor改变，所以需要手动设置，其次就是通过对象字面量给Person.prototype进行赋值，会无法作用在之前创建的对象实例上
var person1 = new Person()
Person.prototype = {
name: &apos;hanmeimei2&apos;,
setName: function(name){
  this.name = name
  }
  }
  person1.setName()   //Uncaught TypeError: person1.set is not a function(…)

  这是因为对象实例和对象原型直接是通过一个指针链接的，这个指针是一个内部属性[[Prototype]]，可以通过__proto__访问。我们通过对象字面量修改了Person.prototype指向的地址，然而对象实例的__proto__，并没有跟着一起更新，所以这就导致，实例还访问着原来的Person.prototype，所以建议不要通过这种方式去改变Person.prototype属性
</code></pre><h3 id="构造函数和原型组合模式"><a href="#构造函数和原型组合模式" class="headerlink" title="构造函数和原型组合模式"></a>构造函数和原型组合模式</h3><pre><code>function Person(name) {
this.name = name
this.friends = [&apos;lilei&apos;]
}
Person.prototype.say = function() {
console.log(this.name)
}
var person1 = new Person(&apos;hanmeimei&apos;)
person1.say() //hanmeimei
</code></pre><p>优点：</p>
<pre><code>1、解决了原型模式对于引用对象的缺点
2、解决了原型模式没有办法传递参数的缺点
3、解决了构造函数模式不能共享方法的缺点
</code></pre><p>缺点：</p>
<pre><code>1、和原型模式中注意①一样
</code></pre><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><pre><code>function Person(name) {
this.name = name
if(typeof this.say != &apos;function&apos;) {
Person.prototype.say = function(
alert(this.name)
}
}
</code></pre><p>优点：</p>
<pre><code>1、可以在初次调用构造函数的时候就完成原型对象的修改
2、修改能体现在所有的实例中
3、缺点：红宝书都说这个方案完美了。。。。
</code></pre><p>注意：</p>
<pre><code>1、只用检查一个在执行后应该存在的方法或者属性就行了
2、不能用对象字面量修改原型对象
</code></pre><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><pre><code>function Person(name) {
var o = new Object()
o.name = name
o.say = function() {
alert(this.name)
}
return o
}
var peron1 = new Person(&apos;hanmeimei&apos;)
</code></pre><p>优点：</p>
<pre><code>1、和工厂模式基本一样，除了多了个new操作符
</code></pre><p>缺点：</p>
<pre><code>2、和工厂模式一样，不能区分实例的类别
</code></pre><h3 id="稳妥构造模式"><a href="#稳妥构造模式" class="headerlink" title="稳妥构造模式"></a>稳妥构造模式</h3><pre><code>function Person(name) {
var o = new Object()
o.say = function() {
alert(name)
}
}
var person1 = new Person(&apos;hanmeimei&apos;);
person1.name  // undefined
person1.say() //hanmeimei
</code></pre><p>优点：</p>
<pre><code>1、安全，那么好像成为了私有变量，只能通过say方法去访问
</code></pre><p>缺点：</p>
<pre><code>1、不能区分实例的类别
</code></pre><p>over!!~~~</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/01/17/JavaScript创建对象的7种方法/" class="archive-article-date">
  	<time datetime="2016-01-17T03:42:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-01-17</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-JavaScript创建对象的7种方法" data-title="JavaScript创建对象的7种方法" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-javascript数据结构-链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/17/javascript数据结构-链表/">javascript数据结构--链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>链表就要来的随性的多，简单的理解可以是这样：在内存中，栈和队列（数组）的存在就是一个整体，如果想要对她内部某一个元素进行移除或是添加一个新元素就要动她内部所有的元素，所谓牵一发而动全身；而链表则不一样，每一个元素都是由元素本身数据和指向下一个元素的指针构成，所以添加或是移除某一个元素不需要对链表整体进行操作，只需要改变相关元素的指针指向就可以了

链表在实际生活中的例子也有很多，比如自行车的链条，环环相扣，但添加或是移除某一个环节只需要对症下药，对相关环节进行操作就OK。再比如：火车，火车就是一个链表，每一节车厢就是元素，想要移除或是添加某一节车厢，只需要把连接车厢的链条改变一下就好了。那么，在javascript中又该怎么去实现链表结构呢？
</code></pre><h2 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h2><p>首先我们要创建一个链表类：</p>
<pre><code>function LinkedList(){
//各种属性和方法的声明
}
</code></pre><p>然后我们需要一种数据结构来保存链表里面的数据：</p>
<pre><code>var Node=function(element){
this.element=element;
this.next=null;}
//Node类表示要添加的元素，他有两个属性，一个是element，表示添加到链表中的具体的值；另一个是next,表示要指向链表中下一个元素的指针。
</code></pre><p>接下来，我们需要给链表声明一些方法：</p>
<pre><code>·append(element):向链表尾部添加一个新的元素；
·insert(position,element):向链表特定位置插入元素；
·remove(element):从链表移除一项；
·indexOf(element):返回链表中某元素的索引，如果没有返回-1；
·removeAt(position):从特定位置移除一项；
·isEmpty():判断链表是否为空，如果为空返回true,否则返回false;
·size():返回链表包含的元素个数；
·toString():重写继承自Object类的toString()方法，因为我们使用了Node类；
</code></pre><p>链表的完整代码：</p>
<pre><code>function LinkedList() {
//Node类声明
let Node = function(element){
    this.element = element;
    this.next = null;
};
//初始化链表长度
let length = 0;
//初始化第一个元素
let head = null;
this.append = function(element){
    //初始化添加的Node实例
    let node = new Node(element),
        current;
    if (head === null){
        //第一个Node实例进入链表，之后在这个LinkedList实例中head就不再是null了
        head = node;
    } else {
        current = head;
        //循环链表知道找到最后一项，循环结束current指向链表最后一项元素
        while(current.next){
            current = current.next;
        }
        //找到最后一项元素后，将他的next属性指向新元素node,j建立链接
        current.next = node;
    }
    //更新链表长度
    length++;
};
this.insert = function(position, element){
    //检查是否越界，超过链表长度或是小于0肯定不符合逻辑的
    if (position &gt;= 0 &amp;&amp; position &lt;= length){
        let node = new Node(element),
            current = head,
            previous,
            index = 0;
        if (position === 0){
            //在第一个位置添加
            node.next = current;
            head = node;
        } else {
            //循环链表，找到正确位置，循环完毕，previous，current分别是被添加元素的前一个和后一个元素
            while (index++ &lt; position){
                previous = current;
                current = current.next;
            }
            node.next = current;
            previous.next = node;
        }
        //更新链表长度
        length++;
        return true;
    } else {
        return false;
    }
};
this.removeAt = function(position){
    //检查是否越界，超过链表长度或是小于0肯定不符合逻辑的
    if (position &gt; -1 &amp;&amp; position &lt; length){
        let current = head,
            previous,
            index = 0;
        //移除第一个元素
        if (position === 0){
            //移除第一项，相当于head=null;
            head = current.next;
        } else {
            //循环链表，找到正确位置，循环完毕，previous，current分别是被添加元素的前一个和后一个元素
            while (index++ &lt; position){
                previous = current;
                current = current.next;
            }
            //链接previous和current的下一个元素，也就是把current移除了
            previous.next = current.next;
        }
        length--;
        return current.element;
    } else {
        return null;
    }
};
this.indexOf = function(element){
    let current = head,
        index = 0;
    //循环链表找到元素位置
    while (current) {
        if (element === current.element) {
            return index;
        }
        index++;
        current = current.next;
    }
    return -1;
};
this.remove = function(element){
    //调用已经声明过的indexOf和removeAt方法
    let index = this.indexOf(element);
    return this.removeAt(index);
};
this.isEmpty = function() {
    return length === 0;
};
this.size = function() {
    return length;
};
this.getHead = function(){
    return head;
};
this.toString = function(){
    let current = head,
        string = &apos;&apos;;
    while (current) {
        string += current.element + (current.next ? &apos;, &apos; : &apos;&apos;);
        current = current.next;
    }
    return string;
};
this.print = function(){
    console.log(this.toString());
};
}

//一个实例化后的链表，里面是添加的数个Node类的实例
</code></pre><p>ES6版本:</p>
<pre><code>let LinkedList2 = (function () {
class Node {
    constructor(element){
        this.element = element;
        this.next = null;
    }
}
//这里我们使用WeakMap对象来记录长度状态
const length = new WeakMap();
const head = new WeakMap();
class LinkedList2 {
    constructor () {
        length.set(this, 0);
        head.set(this, null);
    }
    append(element) {
        let node = new Node(element),
            current;
        if (this.getHead() === null) {
            head.set(this, node);
        } else {
            current = this.getHead();
            while (current.next) {
                current = current.next;
            }
            current.next = node;
        }
        let l = this.size();
        l++;
        length.set(this, l);
    }
    insert(position, element) {
        if (position &gt;= 0 &amp;&amp; position &lt;= this.size()) {

            let node = new Node(element),
                current = this.getHead(),
                previous,
                index = 0;
            if (position === 0) {
                node.next = current;
                head.set(this, node);
            } else {
                while (index++ &lt; position) {
                    previous = current;
                    current = current.next;
                }
                node.next = current;
                previous.next = node;
            }
            let l = this.size();
            l++;
            length.set(this, l);
            return true;
        } else {
            return false;
        }
    }
    removeAt(position) {
        if (position &gt; -1 &amp;&amp; position &lt; this.size()) {
            let current = this.getHead(),
                previous,
                index = 0;
            if (position === 0) {
                head.set(this, current.next);
            } else {
                while (index++ &lt; position) {
                    previous = current;
                    current = current.next;
                }
                previous.next = current.next;
            }
            let l = this.size();
            l--;
            length.set(this, l);
            return current.element;
        } else {
            return null;
        }
    }
    remove(element) {
        let index = this.indexOf(element);
        return this.removeAt(index);
    }
    indexOf(element) {
        let current = this.getHead(),
            index = 0;
        while (current) {
            if (element === current.element) {
                return index;
            }
            index++;
            current = current.next;
        }
        return -1;
    }
    isEmpty() {
        return this.size() === 0;
    }
    size() {
        return length.get(this);
    }
    getHead() {
        return head.get(this);
    }
    toString() {
        let current = this.getHead(),
            string = &apos;&apos;;
        while (current) {
            string += current.element + (current.next ? &apos;, &apos; : &apos;&apos;);
            current = current.next;
        }
        return string;

    }
    print() {
        console.log(this.toString());
    }
}
return LinkedList2;
})();
双向链表
function DoublyLinkedList() {
let Node = function(element){
    this.element = element;
    this.next = null;
    this.prev = null; //NEW
};
let length = 0;
let head = null;
let tail = null; //NEW
this.append = function(element){
    let node = new Node(element),
        current;
    if (head === null){
        head = node;
        tail = node; //NEW
    } else {
        //NEW
        tail.next = node;
        node.prev = tail;
        tail = node;
    }
    length++;
};
this.insert = function(position, element){
    if (position &gt;= 0 &amp;&amp; position &lt;= length){
        let node = new Node(element),
            current = head,
            previous,
            index = 0;
        if (position === 0){
            if (!head){       //NEW
                head = node;
                tail = node;
            } else {
                node.next = current;
                current.prev = node; //NEW
                head = node;
            }
        } else  if (position === length) { ////NEW
            current = tail;   
            current.next = node;
            node.prev = current;
            tail = node;
        } else {
            while (index++ &lt; position){
                previous = current;
                current = current.next;
            }
            node.next = current;
            previous.next = node;
            current.prev = node; //NEW
            node.prev = previous; //NEW
        }
        length++;
        return true;
    } else {
        return false;
    }
};
this.removeAt = function(position){
    if (position &gt; -1 &amp;&amp; position &lt; length){
        let current = head,
            previous,
            index = 0;
        if (position === 0){ //NEW
            if (length === 1){ //
                tail = null;
            } else {
                head.prev = null;
            }
        } else if (position === length-1){  //NEW
            current = tail;
            tail = current.prev;
            tail.next = null;
        } else {
            while (index++ &lt; position){
                previous = current;
                current = current.next;
            }
            previous.next = current.next;
            current.next.prev = previous; //NEW
        }
        length--;
        return current.element;
    } else {
        return null;
    }
};
this.remove = function(element){
    let index = this.indexOf(element);
    return this.removeAt(index);
};
this.indexOf = function(element){
    let current = head,
        index = -1;
    if (element == current.element){
        return 0;
    }
    index++;
    while(current.next){
        if (element == current.element){
            return index;
        }
        current = current.next;
        index++;
    }
    //check last item
    if (element == current.element){
        return index;
    }
    return -1;
};
this.isEmpty = function() {
    return length === 0;
};
this. size = function() {
    return length;
};
this.toString = function(){
    let current = head,
        s = current ? current.element : &apos;&apos;;
    while(current &amp;&amp; current.next){
        current = current.next;
        s += &apos;, &apos; + current.element;
    }
    return s;
};
this.inverseToString = function() {
    let current = tail,
        s = current ? current.element : &apos;&apos;;
    while(current &amp;&amp; current.prev){
        current = current.prev;
        s += &apos;, &apos; + current.element;
    }
    return s;
};
this.print = function(){
    console.log(this.toString());
};
this.printInverse = function(){
    console.log(this.inverseToString());
};
this.getHead = function(){
    return head;
};
this.getTail = function(){
    return tail;
}
}    
</code></pre><p>  双向链表和单项比起来就是Node类多了一个prev属性，也就是每一个node不仅仅有一个指向它后面元素的指针也有一个指向它前面的指针。</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><pre><code>明白了前面的基础链表和双向链表之后这个肯定不在话下了，循环，其实就是整个链表实例变成了一个圈，在单项链表中最后一个元素的next属性为null,现在让它指向第一个元素也就是head，那么他就成了单向循环链表。在双向链表中最后一个元素的next属性为null,现在让它指向第一个元素也就是head，那么他就成了双向循环链表。就那么回事..
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/01/17/javascript数据结构-链表/" class="archive-article-date">
  	<time datetime="2016-01-17T03:05:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-01-17</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-javascript数据结构-链表" data-title="javascript数据结构--链表" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/12/this/">this</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="global-this"><a href="#global-this" class="headerlink" title="global this"></a>global this</h1><p>· 在浏览器，在全局范围内,this等价于window对象.</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2 console.log(this === window); //true
3&lt;/script&gt;
</code></pre><p>· 在浏览器里，在全局范围内，用var声明一个变量和给this或者window添加属性是等价的</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     var foo = &quot;bar&quot;;
3     console.log(this.foo); //logs &quot;bar&quot;
4     console.log(window.foo); //logs &quot;bar&quot;
5 &lt;/script&gt;
</code></pre><p>· 如果你在声明一个变量的时候没有使用var或者let(ECMAScript 6),你就是在给全局的this添加或者改变属性值。</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     foo = &quot;bar&quot;;
3
4     function testThis() {
5       foo = &quot;foo&quot;;
6     }
7
8     console.log(this.foo); //logs &quot;bar&quot;
9     testThis();
10     console.log(this.foo); //logs &quot;foo&quot;
11 &lt;/script&gt;
</code></pre><p>· 在node环境里，如果使用REPL(Read-Eval-Print Loop，简称REPL:读取-求值-输出,是一个简单的，交互式的编程环境)来执行程序,this并不是最高级的命名空间，最高级的是global.</p>
<pre><code>&gt; this
{ ArrayBuffer: [Function: ArrayBuffer],
Int8Array: { [Function: Int8Array] BYTES_PER_ELEMENT: 1 },
...
&gt; global === this
true
</code></pre><p>· 在node环境里，如果执行一个js脚本，在全局范围内，this以一个空对象开始作为最高级的命名空间，这个时候，它和global不是等价的。</p>
<pre><code>1 test.js脚本内容：
2
3 console.log(this);
4 console.log(this === global);
5 
6 REPL运行脚本：
7 
8 $ node test.js
9 {}
10 false
</code></pre><p>· 在node环境里，在全局范围内，如果你用REPL执行一个脚本文件，用var声明一个变量并不会和在浏览器里面一样将这个变量添加给this。</p>
<pre><code>1 test.js:
2 
3 var foo = &quot;bar&quot;;
4 console.log(this.foo);
5 
6 $ node test.js
7 undefined    
</code></pre><p>· 但是如果你不是用REPL执行脚本文件，而是直接执行代码，结果和在浏览器里面是一样的(神坑)</p>
<pre><code>1 &gt; var foo = &quot;bar&quot;;
2 &gt; this.foo
3 bar
4 &gt; global.foo
5 bar
</code></pre><p>· 在node环境里，用REPL运行脚本文件的时候，如果在声明变量的时候没有使用var或者let，这个变量会自动添加到global对象，但是不会自动添加给this对象。如果是直接执行代码，则会同时添加给global和this</p>
<pre><code>1 test.js
2 
3 foo = &quot;bar&quot;;
4 console.log(this.foo);
5 console.log(global.foo);
6 
7 $ node test.js
8 undefined
9 bar


上面的八种情况可能大家已经绕晕了，总结起来就是：在浏览器里面this是老大，它等价于window对象，如果你声明一些全局变量(不管在任何地方)，这些变量都会作为this的属性。在node里面，有两种执行JavaScript代码的方式，一种是直接执行写好的JavaScript文件，另外一种是直接在里面执行一行行代码。对于直接运行一行行JavaScript代码的方式，global才是老大，this和它是等价的。在这种情况下，和浏览器比较相似，也就是声明一些全局变量会自动添加给老大global，顺带也会添加给this。但是在node里面直接脚本文件就不一样了，你声明的全局变量不会自动添加到this，但是会添加到global对象。所以相同点是，在全局范围内，全局变量终究是属于老大的。
</code></pre><h1 id="function-this"><a href="#function-this" class="headerlink" title="function this"></a>function this</h1><p>· 无论是在浏览器环境还是node环境， 除了在DOM事件处理程序里或者给出了thisArg(接下来会讲到)外，如果不是用new调用，在函数里面使用this都是指代全局范围的this。</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     foo = &quot;bar&quot;;
3 
4     function testThis() {
5       this.foo = &quot;foo&quot;;
6     }
7 
8     console.log(this.foo); //logs &quot;bar&quot;
9     testThis();
10     console.log(this.foo); //logs &quot;foo&quot;
11 &lt;/script&gt;

test.js

foo = &quot;bar&quot;;

function testThis () {
this.foo = &quot;foo&quot;;
}
console.log(global.foo);
testThis();console.log(global.foo);
$ node test.js
bar
foo    
</code></pre><p>· 除非你使用严格模式，这时候this就会变成undefined。</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     foo = &quot;bar&quot;;
3 
4     function testThis() {
5       &quot;use strict&quot;;
6       this.foo = &quot;foo&quot;;
7     }
8 
9     console.log(this.foo); //logs &quot;bar&quot;
10     testThis();  //Uncaught TypeError: Cannot set property &apos;foo&apos; of undefined 
11 &lt;/script&gt;
</code></pre><p>· 如果你在调用函数的时候在前面使用了new，this就会变成一个新的值，和global的this脱离干系.</p>
<pre><code>1 &lt;script type=&quot;text/javascript&quot;&gt;
2     foo = &quot;bar&quot;;
3 
4     function testThis() {
5       this.foo = &quot;foo&quot;;
6     }
7 
8     console.log(this.foo); //logs &quot;bar&quot;
9     new testThis();
10     console.log(this.foo); //logs &quot;bar&quot;
11 
12     console.log(new testThis().foo); //logs &quot;foo&quot;
13 &lt;/script&gt;
</code></pre><p>我更喜欢把新的值称作一个实例。</p>
<pre><code>函数里面的this其实相对比较好理解，如果我们在一个函数里面使用this，需要注意的就是我们调用函数的方式，如果是正常的方式调用函数，this指代全局的this，如果我们加一个new，这个函数就变成了一个构造函数，我们就创建了一个实例，this指代这个实例，这个和其他面向对象的语言很像。另外，写JavaScript很常做的一件事就是绑定事件处理程序，也就是诸如button.addEventListener(‘click’, fn, false)之类的，如果在fn里面需要使用this，this指代事件处理程序对应的对象，也就是button。
</code></pre><h1 id="Protoype-this"><a href="#Protoype-this" class="headerlink" title="Protoype this"></a>Protoype this</h1><p>你创建的每一个函数都是函数对象。它们会自动获得一个特殊的属性prototype，你可以给这个属性赋值。当你用new的方式调用一个函数的时候，你就能通过this访问你给prototype赋的值了。</p>
<pre><code>1 function Thing() {
2       console.log(this.foo);
3 }
4 
5 Thing.prototype.foo = &quot;bar&quot;;
6 
7 var thing = new Thing(); //logs &quot;bar&quot;
8 console.log(thing.foo);  //logs &quot;bar&quot;
</code></pre><p>当你使用new为你的函数创建多个实例的时候，这些实例会共享你给prototype设定的值。对于下面的例子，当你调用this.foo的时候，都会返回相同的值，除非你在某个实例里面重写了自己的this.foo</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     console.log(this.foo);
6 }
7 Thing.prototype.setFoo = function (newFoo) {
8     this.foo = newFoo;
9 }
10 
11 var thing1 = new Thing();
12 var thing2 = new Thing();
13 
14 thing1.logFoo(); //logs &quot;bar&quot;
15 thing2.logFoo(); //logs &quot;bar&quot;
16 
17 thing1.setFoo(&quot;foo&quot;);
18 thing1.logFoo(); //logs &quot;foo&quot;;
19 thing2.logFoo(); //logs &quot;bar&quot;;
20 
21 thing2.foo = &quot;foobar&quot;;
22 thing1.logFoo(); //logs &quot;foo&quot;;
23 thing2.logFoo(); //logs &quot;foobar&quot;;
</code></pre><p>实例里面的this是一个特殊的对象。你可以把this想成一种获取prototype的值的一种方式。当你在一个实例里面直接给this添加属性的时候，会隐藏prototype中与之同名的属性。如果你想访问prototype中的这个属性值而不是你自己设定的属性值，你可以通过在实例里面删除你自己添加的属性的方式来实现</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     console.log(this.foo);
6 }
7 Thing.prototype.setFoo = function (newFoo) {
8     this.foo = newFoo;
9 }
10 Thing.prototype.deleteFoo = function () {
11     delete this.foo;
12 }
13 var thing = new Thing();
14 thing.setFoo(&quot;foo&quot;);
15 thing.logFoo(); //logs &quot;foo&quot;;
16 thing.deleteFoo();
17 thing.logFoo(); //logs &quot;bar&quot;;
18 thing.foo = &quot;foobar&quot;;
19 thing.logFoo(); //logs &quot;foobar&quot;;
20 delete thing.foo;
21 thing.logFoo(); //logs &quot;bar&quot;;
</code></pre><p>或者你也能直接通过引用函数对象的prototype 来获得你需要的值</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     console.log(this.foo, Thing.prototype.foo);
6 }
7 
8 var thing = new Thing();
9 thing.foo = &quot;foo&quot;;
10 thing.logFoo(); //logs &quot;foo bar&quot;;
</code></pre><p>给一个函数的prototype赋值一个Array通常是一个错误的做法。如果你想每一个实例有他们专属的Array，你应该在函数里面创建而不是在prototype里面创建。</p>
<pre><code>1 function Thing() {
2     this.things = [];
3 }
4 
5 
6 var thing1 = new Thing();
7 var thing2 = new Thing();
8 thing1.things.push(&quot;foo&quot;);
9 console.log(thing1.things); //logs [&quot;foo&quot;]
10 console.log(thing2.things); //logs []
</code></pre><p>实际上你可以通过把多个函数的prototype链接起来的从而形成一个原型链，因此this就会魔法般地沿着这条原型链往上查找直到找你你需要引用的值。</p>
<pre><code>1 function Thing1() {
2 }
3 Thing1.prototype.foo = &quot;bar&quot;;
4 
5 function Thing2() {
6 }
7 Thing2.prototype = new Thing1();
8 
9 
10 var thing = new Thing2();
11 console.log(thing.foo); //logs &quot;bar&quot;          
</code></pre><p>一些人利用原型链的特性来在JavaScript模仿经典的面向对象的继承方式。任何给用于构建原型链的函数的this的赋值的语句都会隐藏原型链上游的相同的属性</p>
<pre><code>1 function Thing1() {
2 }
3 Thing1.prototype.foo = &quot;bar&quot;;
4 
5 function Thing2() {
6     this.foo = &quot;foo&quot;;
7 }
8 Thing2.prototype = new Thing1();
9 
10 function Thing3() {
11 }
12 Thing3.prototype = new Thing2();
13 
14 
15 var thing = new Thing3();
16 console.log(thing.foo); //logs &quot;foo&quot;
</code></pre><p>我喜欢把被赋值给prototype的函数叫做方法。在上面的例子中，我已经使用过方法了，如logFoo。这些方法有着相同的prototype，即创建这些实力的原始函数。我通常把这些原始函数叫做构造函数。在prototype里面定义的方法里面使用this会影响到当前实例的原型链的上游的this。这意味着你直接给this赋值的时候，隐藏了原型链上游的相同的属性值。这个实例的任何方法都会使用这个最新的值而不是原型里面定义的这个相同的值。</p>
<pre><code>1 function Thing1() {
2 }
3 Thing1.prototype.foo = &quot;bar&quot;;
4 Thing1.prototype.logFoo = function () {
5     console.log(this.foo);
6 }
7 
8 function Thing2() {
9     this.foo = &quot;foo&quot;;
10 }
11 Thing2.prototype = new Thing1();
12 
13 
14 var thing = new Thing2();
15 thing.logFoo(); //logs &quot;foo&quot;;
</code></pre><p>在JavaScript里面你可以嵌套函数，也就是你可以在函数里面定义函数。嵌套函数可以通过闭包捕获父函数的变量，但是这个函数没有继承this</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     var info = &quot;attempting to log this.foo:&quot;;
6     function doIt() {
7         console.log(info, this.foo);
8     }
9     doIt();
10 }
11 
12 
13 var thing = new Thing();
14 thing.logFoo();  //logs &quot;attempting to log this.foo: undefined&quot;
</code></pre><p>在doIt里面的this是global对象或者在严格模式下面是undefined。这是造成很多不熟悉JavaScript的人深陷 this陷阱的根源。在这种情况下事情变得非常糟糕，就像你把一个实例的方法当作一个值，把这个值当作函数参数传递给另外一个函数但是却不把这个实例传递给这个函数一样。在这种情况下，一个方法里面的环境变成了全局范围，或者在严格模式下面的undefined。</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {  
5     console.log(this.foo);   
6 }
7 
8 function doIt(method) {
9     method();
10 }
11 
12 
13 var thing = new Thing();
14 thing.logFoo(); //logs &quot;bar&quot;
15 doIt(thing.logFoo); //logs undefined
</code></pre><p>你可以通过bind将实例和方法一切传递给函数来解决这个问题，bind是一个函数定义在所有函数和方法的函数对象上面</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () { 
5     console.log(this.foo);
6 }
7 
8 function doIt(method) {
9     method();
10 }
11 
12 
13 var thing = new Thing();
14 doIt(thing.logFoo.bind(thing)); //logs bar
</code></pre><p>你同样可以使用apply和call来在新的上下文中调用方法或函数。</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () { 
5     function doIt() {
6         console.log(this.foo)
7     }
8     doIt.apply(this);
9 }
10 
11 function doItIndirectly(method) {
12     method();
13 }
14 
15 
16 var thing = new Thing();
17 doItIndirectly(thing.logFoo.bind(thing)); //logs bar
</code></pre><p>你可以用bind来代替任何一个函数或者方法的this，即便它没有赋值给实例的初始prototype。</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 
5 
6 function logFoo(aStr) {
7     console.log(aStr, this.foo);
8 }
9 
10 
11 var thing = new Thing();
12 logFoo.bind(thing)(&quot;using bind&quot;); //logs &quot;using bind bar&quot;
13 logFoo.apply(thing, [&quot;using apply&quot;]); //logs &quot;using apply bar&quot;
14 logFoo.call(thing, &quot;using call&quot;); //logs &quot;using call bar&quot;
15 logFoo(&quot;using nothing&quot;); //logs &quot;using nothing undefined&quot;    
</code></pre><p>你应该避免在构造函数里面返回任何东西，因为这可能代替本来应该返回的实例.</p>
<pre><code>1 function Thing() {
2     return {};
3 }
4 Thing.prototype.foo = &quot;bar&quot;;
5 
6 
7 Thing.prototype.logFoo = function () {
8     console.log(this.foo);
9 }
10 
11 
12 var thing = new Thing();
13 thing.logFoo(); //Uncaught TypeError: undefined is not a function
</code></pre><p>奇怪的是，如果你在构造函数里面返回了一个原始值，上面所述的情况并不会发生并且返回语句被忽略了。最好不要在你将通过new调用的构造函数里面返回任何类型的数据，即便你知道自己正在做什么。如果你想创建一个工厂模式，通过一个函数来创建一个实例，这个时候不要使用new来调用函数。当然这个建议是可选的。<br>    你可以通过使用Object.create来避免使用new，这样同样能够创建一个实例。</p>
<pre><code>1 function Thing() {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 
5 
6 Thing.prototype.logFoo = function () {
7     console.log(this.foo);
8 }
9 
10 
11 var thing =  Object.create(Thing.prototype);
12 thing.logFoo(); //logs &quot;bar&quot;     
</code></pre><p>在这种情况下并不会调用构造函数</p>
<pre><code>1 function Thing() {
2     this.foo = &quot;foo&quot;;
3 }
4 Thing.prototype.foo = &quot;bar&quot;;
5 
6 
7 Thing.prototype.logFoo = function () {
8     console.log(this.foo);
9 }
10 
11 
12 var thing =  Object.create(Thing.prototype);
13 thing.logFoo(); //logs &quot;bar&quot;    
</code></pre><p>因为Object.create不会调用构造函数的特性在你继承模式下你想通过原型链重写构造函数的时候非常有用。</p>
<pre><code>1 function Thing1() {
2     this.foo = &quot;foo&quot;;
3 }
4 Thing1.prototype.foo = &quot;bar&quot;;
5 
6 function Thing2() {
7     this.logFoo(); //logs &quot;bar&quot;
8     Thing1.apply(this);
9     this.logFoo(); //logs &quot;foo&quot;
10 }
11 Thing2.prototype = Object.create(Thing1.prototype);
12 Thing2.prototype.logFoo = function () {
13     console.log(this.foo);
14 }
15 
16 var thing = new Thing2();
</code></pre><h1 id="DOM-event-this"><a href="#DOM-event-this" class="headerlink" title="DOM event this"></a>DOM event this</h1><p>在一个HTML DOM事件处理程序里面，this始终指向这个处理程序被所绑定到的HTML DOM节点</p>
<pre><code>1 function Listener()     {
2 document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;,
3        this.handleClick);
4 }
5 Listener.prototype.handleClick = function (event) {
6     console.log(this); //logs &quot;&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;&quot;
7 }
8 
9 var listener = new Listener();
10 document.getElementById(&quot;foo&quot;).click();
</code></pre><p>除非你自己通过bind切换了上下文</p>
<pre><code>1 function Listener() {
2     document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;, 
3         this.handleClick.bind(this));
4 }
5 Listener.prototype.handleClick = function (event) {
6     console.log(this); //logs Listener {handleClick: function}
7 }
8 
9 var listener = new Listener();
10 document.getElementById(&quot;foo&quot;).click();
</code></pre><h1 id="HTML-this"><a href="#HTML-this" class="headerlink" title="HTML this"></a>HTML this</h1><p>在HTML节点的属性里面，你可以放置JavaScript代码，this指向了这个元素</p>
<pre><code>1 &lt;div id=&quot;foo&quot; onclick=&quot;console.log(this);&quot;&gt;&lt;/div&gt;
2 &lt;script type=&quot;text/javascript&quot;&gt;
3 document.getElementById(&quot;foo&quot;).click(); //logs &lt;div id=&quot;foo&quot;...
4 &lt;/script&gt;
</code></pre><h1 id="override-this"><a href="#override-this" class="headerlink" title="override this"></a>override this</h1><p>你不能重写this，因为它是保留字。</p>
<pre><code>function Thing () {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {
eval(&quot;console.log(this.foo)&quot;); //logs &quot;bar&quot;
}
var thing = new Thing();
thing.logFoo();    
</code></pre><h1 id="with-this"><a href="#with-this" class="headerlink" title="with this"></a>with this</h1><p>你可以通过with来将this添加到当前的执行环境，并且读写this的属性的时候不需要通过this</p>
<pre><code>1 function Thing () {
2 }
3 Thing.prototype.foo = &quot;bar&quot;;
4 Thing.prototype.logFoo = function () {
5     with (this) {
6         console.log(foo);
7         foo = &quot;foo&quot;;
8     }
9 }
10 
11 var thing = new Thing();
12 thing.logFoo(); // logs &quot;bar&quot;
13 console.log(thing.foo); // logs &quot;foo&quot;    
</code></pre><h1 id="jQuery-this"><a href="#jQuery-this" class="headerlink" title="jQuery this"></a>jQuery this</h1><p>和HTML DOM元素节点的事件处理程序一样，在许多情况下JQuery的this都指向HTML元素节点。这在事件处理程序和一些方便的方法中都是管用的，比如$.each</p>
<pre><code>1 &lt;div class=&quot;foo bar1&quot;&gt;&lt;/div&gt;
2 &lt;div class=&quot;foo bar2&quot;&gt;&lt;/div&gt;
3 &lt;script type=&quot;text/javascript&quot;&gt;
4 $(&quot;.foo&quot;).each(function () {
5     console.log(this); //logs &lt;div class=&quot;foo...
6 });
7 $(&quot;.foo&quot;).on(&quot;click&quot;, function () {
8     console.log(this); //logs &lt;div class=&quot;foo...
9 });
10 $(&quot;.foo&quot;).each(function () {
11     this.click();
12 });
13 &lt;/script&gt;
</code></pre><h1 id="thisArg-this"><a href="#thisArg-this" class="headerlink" title="thisArg this"></a>thisArg this</h1><p>如果你用过underscore.js 或者 lo-dash 你可能知道许多类库的方法可以通过一个叫做thisArg 的函数参数来传递实例，这个函数参数会作为this的上下文。举个例子，这适用于_.each。原生的JavaScript在ECMAScript 5的时候也允许函数传递一个thisArg参数了，比如forEach。事实上，之前阐述的bind，apply和call的使用已经给你创造了传递thisArg参数给函数的机会。这个参数将this绑定为你所传递的对象。</p>
<pre><code>1 function Thing(type) {
2     this.type = type;
3 }
4 Thing.prototype.log = function (thing) {
5     console.log(this.type, thing);
6 }
7 Thing.prototype.logThings = function (arr) {
8    arr.forEach(this.log, this); // logs &quot;fruit apples...&quot;
9    _.each(arr, this.log, this); //logs &quot;fruit apples...&quot;
10 }
11 
12 var thing = new Thing(&quot;fruit&quot;);
13 thing.logThings([&quot;apples&quot;, &quot;oranges&quot;,
&quot;strawberries&quot;, &quot;bananas&quot;]);         
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/01/12/this/" class="archive-article-date">
  	<time datetime="2016-01-12T06:32:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-01-12</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-this" data-title="this" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-boke" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/11/boke/">boke</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="gulp详细入门教程"><a href="#gulp详细入门教程" class="headerlink" title="gulp详细入门教程"></a>gulp详细入门教程</h1><p>最近使用gulp自动化构建工具来开发网站，在此给大家分享下使用gulp的一些使用教程。</p>
<p>一 gulp安装</p>
<p>1、安装Nodejs</p>
<pre><code>1.1、说明:gulp是基于nodejs，理所当然需要安装Nodejs
1.2、安装:打开nodejs官网,点击绿色下载按钮，它会根据系统信息选择对应(.msi文件).
</code></pre><p>2、全局安装gulp</p>
<pre><code>2、1    说明:说明全局安装gulp目的是为了通过她只想gulp任务;
2、2安装:命令提示符执行npm install gulp-g;
2、3查看是否正确安装:命令提示符执行gulp-v,出现版本号为安装成功
</code></pre><p>3、新建package.json文件</p>
<pre><code>3、1 说明:package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件;
3、2 执行命令提示符执行npm init进行手动安装
3.3 安装完成后回在当前文件夹下看到如下package.json
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3164024-76d2e9fa62a00632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mou"><br>    文件说明：</p>
<pre><code>&quot;name&quot;:&quot;test&quot;,//项目名称（必须）
&quot;version&quot;:1.0.0,//项目版本（必须）
&quot;description&quot;:&quot;This is for study gulp             “project !&quot;,//项目描述（必须）
&quot;devDependencies&quot;:{//项目依赖的插件
3.4、查看package.json帮助文档，命令提示符执行npm help package.json
</code></pre><p>4、安装本地gulp及其常用插件</p>
<pre><code>4.1、执行命令行npm install gulo 安装本地gulp
4.2、安装gulo插件:以gulp-sass为例:
    执行名npm install gulp-sass即可安装gulp-sass插件，安装完成后即可在node_modules文件夹下查看到新安装的插件
</code></pre><p>5、新建gulpfile.js文件（必须）</p>
<pre><code>5.1、说明:gulpfile.js是gulp项目目的配置文件,是位于项目根目录的普通js文件（其实将gulp.js放入其他文件夹下也是可以的）
5.2、gulpfile.js文件用法（以gulp-sass为例）
    5.2.1    导入工具包require(&apos;node_modules里对应模块&apos;)
        var gulp=require(&apos;gulp&apos;)
        var less=require(&apos;gulp-less);
    5.2、定义一个testLess任务（自定义任务名称）
        gulp.task(&apos;testLess&apos;,function(){
        gulp.src(&apos;src/less/index.less&apos;)//该任务针对的文件
        .pipe(less())//该任务调用的模块
        .pipe(gulp.dest(&apos;src/css&apos;));/将会在src/css下生成index.css
        })
        gulp.task(&apos;default&apos;,[&apos;watch&apos;],function(){
        //定义默认任务 并让gulp监视文件变化自动执行
        gulp.watch(&apos;sass/*.scss&apos;,[&apos;sass&apos;])
        })
</code></pre><p>#二、gulp常用插件</p>
<p>  1、gulp-uglify(js压缩)<br>安装：npm install –save-dev gulp-uglify</p>
<pre><code>gulpfile.js代码如下:

var gulp = require(&apos;gulp&apos;),
var rename= require(&apos;gulp-rename&apos;)
var uglify= require(&quot;gulp-uglify&quot;);
gulp.task(&apos;rename&apos;,function() {
gulp.src(&apos;src/**/*.js&apos;)
.pipe(uglify())//压缩
.pipe(rename(&apos;index.min.js&apos;))    
.pipe(gulp.dest(&apos;build/js&apos;));});
gulp.task(&apos;default&apos;,[&apos;rename&apos;]);    
uglify= require(&quot;gulp-uglify&quot;);
</code></pre><p>2、gulp-minify-html（html压缩）<br>安装：npm install –save-dev gulp-minify-html</p>
<p>代码如下：    </p>
<pre><code>var gulp = require(&apos;gulp&apos;),
var minifyHtml= require(&quot;gulp-minify-html&quot;);
gulp.task(&apos;minify-html&apos;,function() {
gulp.src(&apos;src/**/*.html&apos;)//要压缩的html文件
 .pipe(minifyHtml())//压缩
 .pipe(gulp.dest(&apos;build&apos;));});
 gulp.task(&apos;default&apos;,[&apos;minify-html&apos;]);
</code></pre><p>3、 gulp-concat (js文件合并)</p>
<p>安装：npm install –save-dev gulp-concat</p>
<p>代码如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
concat= require(&quot;gulp-concat&quot;);
gulp.task(&apos;concat&apos;,function() {
gulp.src(&apos;src/**/*.js&apos;)  //要合并的文件
.pipe(concat(&apos;index.js&apos;))  //合并匹配到的js文件并命名为 &quot;index.js&quot;
 .pipe(gulp.dest(&apos;build/js&apos;));});
 gulp.task(&apos;default&apos;,[&apos;concat&apos;]);
</code></pre><p>4、gulp-jada</p>
<p>安装：npm install –save-dev  gulp-jada</p>
<p>Gulpfile.js代码如下：</p>
<pre><code>var gulp= require(&apos;gulp&apos;);
var jade= require(&apos;gulp-jade&apos;);
gulp.task(&quot;jade&quot;,function(){
gulp.src(&quot;./jade/*.jade&quot;)
 .pipe(jade({
 pretty:true
 }))
  .pipe(gulp.dest(&quot;html/&quot;))
  })
   gulp.task(&quot;default&quot;,[&quot;watch&quot;],function(){
    gulp.watch(&quot;jade/*.jade&quot;,[&quot;jade&quot;]);
    })
</code></pre><p>5、gulp-less        </p>
<p>安装：npm install –save-dev  gulp-less</p>
<p>Gulpfile.js代码如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
var less= require(&quot;gulp-less&quot;);
gulp.task(&apos;compile-less&apos;,function() {
 gulp.src(&apos;src/less/*.less&apos;)
  .pipe(less())
   .pipe(gulp.dest(&apos;build/css&apos;));
   });
   gulp.task(&apos;default&apos;,[&apos;compile-less&apos;]);
</code></pre><p>6、gulp-sass</p>
<p>安装：npm install –save-dev  gulp-sass</p>
<p>代码如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
var sass= require(&quot;gulp-sass&quot;);
gulp.task(&apos;compile-sass&apos;,function() {
 gulp.src(&apos;src/sass/*.sass&apos;)
 .pipe(sass())
  .pipe(gulp.dest(&apos;build/css&apos;));
  });
  gulp.task(&apos;default&apos;,[&apos;compile-sass&apos;]);
</code></pre><p>7、gulp-imagemin（图片压缩</p>
<p>安装：npm install –save-dev  gulp-imagemin</p>
<p>代码如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;);
var imagemin = require(&apos;gulp-imagemin&apos;);
gulp.task(&apos;uglify-imagemin&apos;,function()    {returngulp.src(&apos;src/images/*&apos;)
.pipe(imagemin())
 .pipe(gulp.dest(&apos;build/images&apos;));
 });
 gulp.task(&apos;default&apos;,[&apos;uglify-imagemin&apos;]);
</code></pre><p>8、理解Browserify</p>
<p>browserify是一个使用node支持的CommonJS模块标准 来为浏览器编译模块的，可以解决模块及依赖管理；</p>
<p>先来看看使用gulp常见的问题：</p>
<p>1、 使用 gulp 过程中，偶尔会遇到 Streaming not supported 这样的错误。这通常是因为常规流与 vinyl 文件对象流有差异、<br>gulp 插件默认使用了只支持 buffer （不支持 stream）的库。比如，不能把 Node 常规流直接传递给 gulp 及其插件。</p>
<p>比如如下代码：会抛出异常的；</p>
<pre><code>vargulp = require(&apos;gulp&apos;);
varuglify = require(&apos;gulp-uglify&apos;);
varconcat = require(&apos;gulp-concat&apos;);
varrename = require(&apos;gulp-rename&apos;);varfs = require(&apos;fs&apos;);
gulp.task(&apos;bundle&apos;,function() {returnfs.createReadStream(&apos;./test.txt&apos;)
.pipe(uglify())
.pipe(rename(&apos;bundle.min.js&apos;))
 .pipe(gulp.dest(&apos;dist/&apos;));
 });
 gulp.task(&apos;default&apos;,[&apos;bundle&apos;]);
</code></pre><p>希望能帮助到你们~~            </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/01/11/boke/" class="archive-article-date">
  	<time datetime="2016-01-11T13:26:36.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-01-11</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-boke" data-title="boke" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wzj1996"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 特仑苏
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>